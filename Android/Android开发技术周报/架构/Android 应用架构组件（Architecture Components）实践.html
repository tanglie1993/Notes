<html>
<head>
  <title>Android 应用架构组件（Architecture Components）实践</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/305825 (zh-CN, DDL); Windows/10.0.15063 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="2859"/>
<h1>Android 应用架构组件（Architecture Components）实践</h1>

<div><span><div style="-evernote-webclip:true"><br/><div><div><div><div><h1> Android 应用架构组件（Architecture Components）实践 </h1><div><div></div></div></div>
        

        <div>
          
            
              
              
                Posted on
              
              <span>
                2017-08-06
              </span>
            

            

            
          

          

          
            
          

          
          
             
               |
               
               
                 Views 
               
                 5125
             
          

          

          

          

        </div>
      
    


    <div>

      
      

      
        <p>Architecture Components 是在 2017 年 Google I/O 大会上，Google 官方推出的一个构建 Android 应用架构的库。它可以帮你避免在 Android 应用开发中常见的一些问题，比如：内存泄露，管理组件生命周期等等。本文将介绍如何利用 Architecture Components 库开发一个实际的 Android 应用 <a href="https://github.com/lijiankun24/ArchitecturePractice" target="_blank">ArchitecturePractice</a>，欢迎 fork 和 star。</p>
<p>本文主要分为以下两部分：</p>
<ol>
<li>介绍 Architecture Components 库；</li>
<li>如何使用 Architecture Components 库开发应用。</li>
</ol>

<h2>关于 Architecture Components</h2><h3>应用开发者所面对的问题</h3><p>在资源有限的移动设备中，在任何时候，系统都有可能为新的应用杀死一些原来的应用，那么在原来应用中的组件（Activity、Fragment、Service等等）也会被销毁，这些组件的生命周期不受开发者控制，而是由系统控制的，所以<strong>不要在应用程序组件中存储任何应用数据和状态</strong>，并且应用程序组件之间相互不要依赖。</p>
<h3>常见的构建原则</h3><p>如果不可以在应用程序组件中存储应用数据和状态，那么该如何构建应用呢？这儿有两条常见的构建原则：</p>
<ul>
<li>关注点分离：一个常见的错误是在 Activity 和 Fragment 中编写所有的代码。任何和UI或者操作系统交互无关的代码都尽量不要出现在这些类中，尽量保持这些类的精简会帮助你避免很多和生命周期相关的问题。最好减少对它们的依赖以提供一个稳定的用户体验。</li>
<li>通过 Model 驱动 UI，最好是持久化的 Model。最好使用持久化的数据有两个原因：a. 如果系统销毁应用释放资源，用户也不用担心丢失数据； b. 即使网络连接不可靠或者断网，应用仍将继续运行。Model 是负责处理应用数据的组件，Model 独立运行于应用中的 View 和应用程序中的其他组件，因此 Model 和其他应用程序组件的生命周期无关。基于 Model 构建的应用程序，其管理数据的职责明确，所以更容易测试，而且稳定性更高。</li>
</ul>
<h3>主要内容</h3><h4>处理生命周期</h4><p>在 <a href="https://developer.android.com/reference/android/arch/lifecycle/package-summary.html" target="_blank">android.arch.lifecycle</a> 包中提供了可以构建生命周期感知的组件的类和接口，这些组件可以根据 Activity/Fragment 的生命周期自动调整它的行为。</p>
<ul>
<li><a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.html" target="_blank">Lifecycle</a>：它是一个持有 Activity/Fragment 生命周期状态信息的类，并且允许其他对象观察此状态。</li>
<li><a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner.html" target="_blank">LifecycleOwner</a>：是一个具有单一方法的接口。如果一个类实现了此接口，则该类中需要持有一个 <code>Lifecycle</code> 对象，并通过<code>LifecycleOwner#getLifecycle()</code> 方法返回该对象。<blockquote>
<p>并不是只有 Activity 和 Fragment 才可以实现 LifecycleOwner 接口的，任何和 Activity/Fragment 生命周期有关系的类都可以实现此接口。通过实现此接口，该类完全是生命周期可感知的，只需要对它进行初始化，它就可以进行自己的初始化和清理操作，而不受其 Activity/Fragment 的管理。详细可以参看官方文档说明：<a href="https://developer.android.com/topic/libraries/architecture/lifecycle.html#lco" target="_blank">LifecycleOwner 实践</a></p>
</blockquote>
</li>
</ul>
<h4>LiveData</h4><p><code>LiveData</code> 是一个数据持有类，它持有一个值并且该值可以被观察。不同于普通的可观察者，<code>LiveData</code> 遵从应用组件的生命周期，这样 <code>Observer</code> 便可以指定一个其应该遵循的 <code>Lifecycle</code>。</p>
<p>如果 <code>Observer</code> 所依附的 <code>Lifecycle</code> 处于 <code>STARTED</code> 或者 <code>RESUMED</code> 状态，则 <code>LiveData</code> 认为 <code>Observer</code> 处于活跃状态。</p>
<p>可以感知组件生命周期的 <code>LiveData</code> 给我们提供了一种可能：可以在多个 <code>Activity</code>、<code>Fragment</code> 之间共享它。</p>
<p>使用 <code>LiveData</code> 会有以下几个优势：</p>
<ul>
<li>避免内存泄露：因为 <code>Observer</code> 是绑定到 <code>Lifecycle</code> 对象上的，当 <code>Lifecycle</code> 对象被销毁的时候，<code>LiveData</code> 对象也会被自动清除</li>
<li>不会因为 <code>Activity</code> 停止而使应用崩溃：如果 <code>Observer</code> 所绑定的 <code>Lifecycle</code> 处于闲置状态（例如：<code>Activity</code> 处于后台运行时），他们不会接收到改变的事件</li>
<li>始终保持最新的数据：如果一个 <code>Lifecycle</code> 重新启动以后（例如：<code>Activity</code> 从后台重新开始运行于前台），它会接收到最新的数据（除非没有最新的数据）</li>
<li>正确处理配置改变：如果一个 <code>Activity</code> 或者 <code>Fragment</code> 以为配置改变（例如：旋转屏幕）被重建以后，<code>LiveData</code> 将会接收到最新的数据</li>
<li>资源共享：通过单例模式，可以在多个 <code>Activity</code> 或者 <code>Fragment</code> 之间共享 <code>LiveData</code> 数据。</li>
<li>不再手动的处理生命周期：<code>Fragment</code> 只有在处于活跃的时候才会观察 <code>LiveData</code> 数据。由于 <code>Fragment</code> 提供了 <code>Lifecycle</code> 对象，所以 <code>LiveData</code> 会管理这一切。</li>
</ul>
<p>有时候，也许想在 <code>LiveData</code> 被下发到 <code>Observer</code> 之前，改变 <code>LiveData</code> 的值，或者是基于当前的 <code>LiveData</code> 下发另一个不同的 <code>LiveData</code> 值。<code>Lifecycle</code> 包中的 <a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations.html" target="_blank"><code>Transformations</code></a> 可以实现这样的功能。</p>
<ul>
<li><p><code>Transformations.map()</code>，使用此方法，可以将 <code>LiveData</code> 传递到下游</p>
<div><table><tbody><tr><td><pre><div>1</div><div>2</div><div>3</div><div>4</div></pre></td><td><pre><div>LiveData&lt;User&gt; userLiveData = ...;</div><div>LiveData&lt;String&gt; userName = Transformations.map(userLiveData, user -&gt; {</div><div>    user.name + &quot; &quot; + user.lastName</div><div>});</div></pre></td></tr></tbody></table></div>
</li>
<li><p><code>Transformations.switchMap()</code>，和 <code>map()</code> 方法类似，使用 <code>switchMap()</code> 应用于 <code>LiveData</code> 的值并解包，然后将结果传递到下游。传递给 <code>switchMap()</code> 的方法必须返回一个 <code>Lifecycle</code></p>
<div><table><tbody><tr><td><pre><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div></pre></td><td><pre><div>private LiveData&lt;User&gt; getUser(String id) {</div><div>  ...;</div><div>}</div><div>LiveData&lt;String&gt; userId = ...;</div><div>LiveData&lt;User&gt; user = Transformations.switchMap(userId, id -&gt; getUser(id) );</div></pre></td></tr></tbody></table></div>
</li>
</ul>
<p>使用这两个转换，允许在整个调用链中携带观察者的 <code>Lifecycle</code> 信息，这样的话，只有在观察者观察到 <code>LiveData</code> 的返回值时，才会运算这些转换。</p>
<p>当你需要在 <code>ViewModel</code> 中添加一个 <code>Lifecycle</code> 对象时，<code>Transformations</code> 或许是一个好的解决办法。</p>
<h4>ViewModel</h4><p><a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel.html" target="_blank">ViewModel</a> 类是用来存储和管理 UI 相关的数据，这样在配置发生变化（例如：屏幕旋转）时，数据就不会丢失。<br/>由于应用程序组件（例如：Activity、Fragment），具有一个由 Android Framework 管理的生命周期，Activity 或 Fragment 在某些情况下（比如：内存紧张或者屏幕旋转）会发生销毁或者重新创建的情况。这样就会带来一些问题：</p>
<ul>
<li>由于 Activity 或者 Fragment 有可能会被销毁或重新创建，所以保存于其中的数据有可能会丢失</li>
<li>在 Activity 或者 Fragment 中会经常发起一些需要一定时间才会返回结果的异步请求调用</li>
<li>如果把处理应用数据、完成响应用户操作、处理系统通信工作的代码都写在 Activity 或者 Fragment 中，那么 Activity 或者 Fragment 将会变得非常的臃肿，给维护工作带来一定的困难</li>
</ul>
<p>针对以上问题，Lifecycle 提供了一个叫 ViewModel 的类，一个 UI 控制器的帮助类，用来为 UI 准备数据。</p>
<p>在配置更改的时候，ViewModel 会被保留，以便其保存的数据可以立即传递给重新创建的 Activity 或者 Fragment 实例中。如果 Activity 被重新创建，它将会收到由之前的 Activity 或者 Fragment 创建的 ViewModel 实例。当所有者 Activity 被销毁以后，Framework 会调用 ViewModel#onCleared() 清楚系统资源。</p>
<h5>在多个 Fragment 之间共享数据</h5><p>在同一个 Activity 中的多个 Fragment 之间进行通信是十分常见的需求，目前通常的做法是新建一个接口，并且用 Activity 将多个 Fragment 联系起来。如果需要通信的数据比较多，就会出现接口泛滥的情况。</p>
<p>使用 ViewModel 可以解决这个痛点。在同一个 Activity 中的 Fragment 可以使用此 Activity 限定的 ViewModel 来处理该通讯。比如如下代码所示：</p><div><table><tbody><tr><td><pre><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div></pre></td><td><pre><div>public class SharedViewModel extends ViewModel {</div><div>    private final MutableLiveData&lt;Item&gt; selected = new MutableLiveData&lt;Item&gt;();</div><div>    public void select(Item item) {</div><div>        selected.setValue(item);</div><div>    }</div><div>    public LiveData&lt;Item&gt; getSelected() {</div><div>        return selected;</div><div>    }</div><div>}</div><div>public class MasterFragment extends Fragment {</div><div>    private SharedViewModel model;</div><div>    public void onActivityCreated() {</div><div>        model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class);</div><div>        itemSelector.setOnClickListener(item -&gt; {</div><div>            model.select(item);</div><div>        });</div><div>    }</div><div>}</div><div>public class DetailFragment extends LifecycleFragment {</div><div>    public void onActivityCreated() {</div><div>        SharedViewModel model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class);</div><div>        model.getSelected().observe(this, { item -&gt;</div><div>           // 更新 UI</div><div>        });</div><div>    }</div><div>}</div></pre></td></tr></tbody></table></div><p>在上面示例代码中，获取 ViewModelProvider 时两个 Fragment 都使用 getActivity() 方法，这就意味着，它们会收到同一个 Activity 限制的同一个 ViewModel 实例对象。这样做有以下几个优点：</p>
<ul>
<li>Activity 不需要知道该通信的任何事情</li>
<li>Fragment 之间不受相互影响。除了 ViewModel 之外，Fragment 不需要了解彼此，就算一个 Fragment 被销毁了，另一个也可以正常工作。而且每个 Fragment 都有自己独立的生命周期，不受其他 Fragment 的影响。</li>
</ul>
<h5>ViewModel 的生命周期</h5><p>ViewModel 对象存在于内存当中，直到传递给它的 Lifecycle 对象被完成的销毁（Activity：被完全销毁，Fragment：被完成移除）。其生命周期图如下所示：</p>
<div>    <a href="http://lijiankun24.com/Android-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%EF%BC%88Architecture-Components%EF%BC%89%E5%AE%9E%E8%B7%B5/viewmodel-lifecycle.png" target="_blank"><div><img src="Android 应用架构组件（Architecture Components）实践_files/Image.png" type="image/png" data-filename="" height="543" width="522"/></div></a></div>

<h5>ViewModel vs SavedInstanceState</h5><ul>
<li>ViewModels 提供了一种在配置更改时保存数据的简便方式，但是如果应用进程被操作系统杀死，那么数据则没有机会被恢复。</li>
<li>通过 SavedInstanceState 保存的数据，存在于操作系统进程的内存中。当用户离开应用数个小时之后，应用的进程很有可能被操作系统杀死，通过 SavedInstanceState 保存的数据，则可以在 Activity 或者 Fragment 重新创建的时候，在其中的 <code>onCreate()</code> 方法中通过 Bundle 恢复数据。</li>
</ul>
<h4>Room Persistence Library</h4><p>Room 在 SQLite 之上提供了一个抽象层，以便在利用 SQLite 全部功能的同时也可以流畅发访问数据库。<br/>在 Room 中有非常重要的三个类：</p>
<ul>
<li>Database：可以使用此组件创建一个数据库持有者。使用注解定义实体列表，通过类的内容定义数据库中数据访问对象列表。它也是底层连接的主要切入点。<blockquote>
<p>注解的类应该是一个继承了 <code>RoomDatabase</code> 的抽象类。在运行时，可以通过 <code>Room.databaseBuilder()</code> 或者 <code>Room.inMemoryDatabaseBuilder()</code> 方法获取单例。</p>
</blockquote>
</li>
<li>Entity：该组件代表了一个表示数据库中某个数据表某一行的类。对于每个 Entity 类，都会在数据库中创建一个数据表保存该类的对象。必须通过  <code>Database</code> 中的 <code>entities</code> 字段引用 Entity 类。Entity 类中的每个字段都会持久化到数据中，除非使用 <code>@Ignore</code> 注解修饰</li>
<li>DAO：该组件表示一个数据访问对象（DAO）的类或者接口。DAO 是 Room 的主要组件，其职责是定义方法来访问数据库。被 <code>@Database</code> 注解修饰的类必须包含一个没有参数的抽象方法，该方法的返回值是被 <code>@Dao</code> 注解的类。在编译时生成代码时，Room 创建该类的实现。</li>
</ul>
<p>Room 中的三大组件与应用程序中其他部分的关系如下图所示：</p>
<div>    <a href="http://lijiankun24.com/Android-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%EF%BC%88Architecture-Components%EF%BC%89%E5%AE%9E%E8%B7%B5/room_architecture.png" target="_blank"><div><img src="Android 应用架构组件（Architecture Components）实践_files/Image [1].png" type="image/png" data-filename="" height="520" width="576"/></div></a></div>

<p>关于 Room Persistence Library 更加详细的内容，请参阅 <a href="https://developer.android.com/topic/libraries/architecture/room.html" target="_blank">Room Persistence Library</a> 官方说明文档。</p>
<h2>Architecture Components 的使用</h2><h3>添加组件到项目</h3><h4>添加 Google Maven 仓库</h4><p>在应用工程的 <code>build.gradle</code> 文件中添加依赖对 Google Maven 的依赖：</p><div><table><tbody><tr><td><pre><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div></pre></td><td><pre><div>allprojects {</div><div>    repositories {</div><div>        jcenter()</div><div>        maven { url 'https://maven.google.com' }</div><div>    }</div><div>}</div></pre></td></tr></tbody></table></div><h4>添加 Architecture Components 组件</h4><p>在应用或者模块的 <code>build.gradle</code> 文件中添加对 Architecture Components 的依赖，如下所示：</p><div><table><tbody><tr><td><pre><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div></pre></td><td><pre><div>// Lifecycles, LiveData 和 ViewModel</div><div>compile &quot;android.arch.lifecycle:runtime:1.0.0-alpha5&quot;</div><div>compile &quot;android.arch.lifecycle:extensions:1.0.0-alpha5&quot;</div><div>annotationProcessor &quot;android.arch.lifecycle:compiler:1.0.0-alpha5&quot;</div><div>// Room</div><div>compile &quot;android.arch.persistence.room:runtime:1.0.0-alpha5&quot;</div><div>annotationProcessor &quot;android.arch.persistence.room:compiler:1.0.0-alpha5&quot;</div><div>// 对 RxJava 的支持</div><div>compile &quot;android.arch.persistence.room:rxjava2:1.0.0-alpha5&quot;</div><div>// 对测试 Room 的支持</div><div>testCompile &quot;android.arch.persistence.room:testing:1.0.0-alpha5&quot;</div></pre></td></tr></tbody></table></div><h3>具体应用</h3><p>假如在项目中有类似于下面知乎列表这样的一个页面：</p>
<div>    <a href="http://lijiankun24.com/Android-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%EF%BC%88Architecture-Components%EF%BC%89%E5%AE%9E%E8%B7%B5/zhihu_list.jpg" target="_blank"><div><img src="Android 应用架构组件（Architecture Components）实践_files/Image.jpg" type="image/jpeg" data-filename="" height="1024" width="576"/></div></a></div>

<p>关于该页面有如下两个接口：</p><div><table><tbody><tr><td><pre><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div></pre></td><td><pre><div>// 请求最新的知乎列表（下拉刷新）</div><div>https://news-at.zhihu.com/api/4/news/latest</div><div>// 上拉加载历史列表（上拉加载更多）</div><div>https://news-at.zhihu.com/api/4/news/before/{date}</div></pre></td></tr></tbody></table></div><p>根据上面两个接口和 “UI设计稿”，再根据 Architecture Components 组件中提供的类，我们一步步完成此页面。首先我们分三步：</p>
<ul>
<li>UI 界面的实现</li>
<li>中间层 ViewModel（UI 界面和数据层连接的桥梁）</li>
<li>数据层（本地持久化数据和服务器端的网络数据）</li>
</ul>
<h4>View 界面</h4><p>此页面使用 Fragment 控制并显示，将其命名为 <code>ZhihuListFragment.java</code>，其布局文件 <code>fragment_zhihu_list.xml</code> 如下所示：</p><div><table><tbody><tr><td><pre><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div><div>33</div><div>34</div><div>35</div></pre></td><td><pre><div>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div>&lt;RelativeLayout</div><div>    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div>    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div>    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</div><div>    android:id=&quot;@+id/rl_zhihu_root&quot;</div><div>    android:layout_width=&quot;match_parent&quot;</div><div>    android:layout_height=&quot;match_parent&quot;&gt;</div><div>    &lt;android.support.v4.widget.SwipeRefreshLayout</div><div>        android:id=&quot;@+id/srl_zhihu&quot;</div><div>        android:layout_width=&quot;match_parent&quot;</div><div>        android:layout_height=&quot;match_parent&quot;&gt;</div><div>        &lt;android.support.v7.widget.RecyclerView</div><div>            android:id=&quot;@+id/rv_zhihu_list&quot;</div><div>            android:name=&quot;com.lijiankun24.architecturepractice.fragment.GirlFragment&quot;</div><div>            android:layout_width=&quot;match_parent&quot;</div><div>            android:layout_height=&quot;match_parent&quot;</div><div>            app:layoutManager=&quot;LinearLayoutManager&quot;</div><div>            tools:context=&quot;.ui.fragment.GirlListFragment&quot;</div><div>            tools:listitem=&quot;@layout/fragment_girl_list_item&quot;/&gt;</div><div>    &lt;/android.support.v4.widget.SwipeRefreshLayout&gt;</div><div>    &lt;!-- ProgressBar颜色更改  http://www.voidcn.com/blog/dongbeitcy/article/p-5781104.html --&gt;</div><div>    &lt;ProgressBar</div><div>        android:id=&quot;@+id/bar_load_more_zhihu&quot;</div><div>        style=&quot;?android:attr/progressBarStyleHorizontal&quot;</div><div>        android:layout_width=&quot;match_parent&quot;</div><div>        android:layout_height=&quot;wrap_content&quot;</div><div>        android:layout_alignParentBottom=&quot;true&quot;</div><div>        android:indeterminate=&quot;true&quot;</div><div>        android:indeterminateTint=&quot;@color/colorPrimaryDark&quot;</div><div>        android:indeterminateTintMode=&quot;src_atop&quot;/&gt;</div><div>&lt;/RelativeLayout&gt;</div></pre></td></tr></tbody></table></div><p><code>fragment_zhihu_list.xml</code> 布局文件比较简单，不需要多讲。</p>
<p><code>ZhihuListFragment.java</code> 代码如下所示：</p><div><table><tbody><tr><td><pre><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div><div>33</div><div>34</div><div>35</div><div>36</div><div>37</div><div>38</div><div>39</div><div>40</div><div>41</div><div>42</div><div>43</div><div>44</div><div>45</div><div>46</div><div>47</div><div>48</div><div>49</div><div>50</div><div>51</div><div>52</div><div>53</div><div>54</div><div>55</div><div>56</div><div>57</div><div>58</div><div>59</div><div>60</div><div>61</div><div>62</div><div>63</div><div>64</div><div>65</div><div>66</div><div>67</div><div>68</div><div>69</div><div>70</div><div>71</div><div>72</div><div>73</div><div>74</div><div>75</div><div>76</div><div>77</div><div>78</div><div>79</div><div>80</div><div>81</div><div>82</div><div>83</div><div>84</div><div>85</div><div>86</div><div>87</div><div>88</div><div>89</div><div>90</div><div>91</div><div>92</div><div>93</div><div>94</div><div>95</div><div>96</div><div>97</div><div>98</div><div>99</div><div>100</div><div>101</div><div>102</div><div>103</div><div>104</div><div>105</div><div>106</div><div>107</div><div>108</div><div>109</div><div>110</div><div>111</div><div>112</div><div>113</div><div>114</div><div>115</div><div>116</div><div>117</div><div>118</div><div>119</div><div>120</div><div>121</div><div>122</div><div>123</div><div>124</div><div>125</div><div>126</div><div>127</div><div>128</div><div>129</div><div>130</div><div>131</div><div>132</div><div>133</div><div>134</div><div>135</div><div>136</div><div>137</div><div>138</div></pre></td><td><pre><div>/**</div><div> * ZhihuListFragment.java</div><div> * &lt;p&gt;</div><div> * Created by lijiankun on 17/7/30.</div><div> */</div><div>public class ZhihuListFragment extends LifecycleFragment {</div><div>    // ZhihuListFragment 所对应的 ViewModel 类的对象</div><div>    private ZhihuListViewModel mListViewModel = null;</div><div>    private SwipeRefreshLayout mRefreshLayout = null;</div><div>    private ZhihuListAdapter mAdapter = null;</div><div>    private ProgressBar mLoadMorebar = null;</div><div>    private View mRLZhihuRoot = null;</div><div>    // 自定义接口，将 RecyclerView 的 Adapter 对其中每个 Item 的点击事件会传到 ZhihuListFragment 中。</div><div>    private final OnItemClickListener&lt;ZhihuStory&gt; mZhihuOnItemClickListener =</div><div>            new OnItemClickListener&lt;ZhihuStory&gt;() {</div><div>                @Override</div><div>                public void onClick(ZhihuStory zhihuStory) {</div><div>                    if (Util.isNetworkConnected(MyApplication.getInstance())) {</div><div>                        ZhihuActivity.startZhihuActivity(getActivity(), zhihuStory.getId(),</div><div>                                zhihuStory.getTitle());</div><div>                    } else {</div><div>                        Util.showSnackbar(mRLZhihuRoot, getString(R.string.network_error));</div><div>                    }</div><div>                }</div><div>            };</div><div>    @Override</div><div>    public View onCreateView(LayoutInflater inflater, ViewGroup container,</div><div>                             Bundle savedInstanceState) {</div><div>        View view = inflater.inflate(R.layout.fragment_zhihu_list, container, false);</div><div>        initView(view);</div><div>        return view;</div><div>    }</div><div>    @Override</div><div>    public void onActivityCreated(@Nullable Bundle savedInstanceState) {</div><div>        super.onActivityCreated(savedInstanceState);</div><div>        subscribeUI();</div><div>    }</div><div>    /**</div><div>     * 将 ZhihuListFragment 对应的 ZhihuListViewModel 类中的 LiveData 添加注册监听到</div><div>     * 此 ZhihuListFragment</div><div>     */</div><div>    private void subscribeUI() {</div><div>        // 通过 ViewModelProviders 创建对应的 ZhihuListViewModel 对象</div><div>        ZhihuListViewModel.Factory factory = new ZhihuListViewModel</div><div>                .Factory(MyApplication.getInstance()</div><div>                , Injection.getDataRepository(MyApplication.getInstance()));</div><div>        mListViewModel = ViewModelProviders.of(this, factory).get(ZhihuListViewModel.class);</div><div>        mListViewModel.getZhihuList().observe(this, new Observer&lt;List&lt;ZhihuStory&gt;&gt;() {</div><div>            @Override</div><div>            public void onChanged(@Nullable List&lt;ZhihuStory&gt; stories) {</div><div>                if (stories == null || stories.size() &lt;= 0) {</div><div>                    return;</div><div>                }</div><div>                L.i(&quot;size is &quot; + stories.size());</div><div>                mAdapter.setStoryList(stories);</div><div>            }</div><div>        });</div><div>        mListViewModel.isLoadingZhihuList().observe(this, new Observer&lt;Boolean&gt;() {</div><div>            @Override</div><div>            public void onChanged(@Nullable Boolean aBoolean) {</div><div>                if (aBoolean == null) {</div><div>                    return;</div><div>                }</div><div>                L.i(&quot;state &quot; + aBoolean);</div><div>                mRefreshLayout.setRefreshing(false);</div><div>                mLoadMorebar.setVisibility(aBoolean ? View.VISIBLE : View.INVISIBLE);</div><div>            }</div><div>        });</div><div>        mListViewModel.refreshZhihusData();</div><div>    }</div><div>    /**</div><div>     * 初始化页面 UI</div><div>     *</div><div>     * @param view Fragment 的 View</div><div>     */</div><div>    private void initView(View view) {</div><div>        if (view == null) {</div><div>            return;</div><div>        }</div><div>        LinearLayoutManager layoutManager = new LinearLayoutManager(getContext());</div><div>        mAdapter = new ZhihuListAdapter(getContext(), mZhihuOnItemClickListener);</div><div>        RecyclerView recyclerView = view.findViewById(R.id.rv_zhihu_list);</div><div>        recyclerView.setAdapter(mAdapter);</div><div>        recyclerView.setLayoutManager(layoutManager);</div><div>        recyclerView.addOnScrollListener(new ZhihuOnScrollListener());</div><div>        mRefreshLayout = view.findViewById(R.id.srl_zhihu);</div><div>        mRefreshLayout.setOnRefreshListener(new ZhihuSwipeListener());</div><div>        mRefreshLayout.setColorSchemeResources(</div><div>                android.R.color.holo_blue_bright,</div><div>                android.R.color.holo_green_light,</div><div>                android.R.color.holo_orange_light,</div><div>                android.R.color.holo_red_light);</div><div>        mLoadMorebar = view.findViewById(R.id.bar_load_more_zhihu);</div><div>        mRLZhihuRoot = view.findViewById(R.id.rl_zhihu_root);</div><div>    }</div><div>    /**</div><div>     * ZhihuSwipeListener 用于 SwipeRefreshLayout 下拉刷新操作</div><div>     */</div><div>    private class ZhihuSwipeListener implements SwipeRefreshLayout.OnRefreshListener {</div><div>        @Override</div><div>        public void onRefresh() {</div><div>            mAdapter.clearStoryList();</div><div>            mListViewModel.refreshZhihusData();</div><div>        }</div><div>    }</div><div>    /**</div><div>     * ZhihuOnScrollListener 用于 RecyclerView 下拉到最低端时的上拉加载更多操作</div><div>     */</div><div>    private class ZhihuOnScrollListener extends RecyclerView.OnScrollListener {</div><div>        @Override</div><div>        public void onScrollStateChanged(RecyclerView recyclerView, int newState) {</div><div>            LinearLayoutManager layoutManager = (LinearLayoutManager)</div><div>                    recyclerView.getLayoutManager();</div><div>            int lastPosition = layoutManager</div><div>                    .findLastCompletelyVisibleItemPosition();</div><div>            if (lastPosition == mAdapter.getItemCount() - 1) {</div><div>                // 上拉加载更多数据</div><div>                mListViewModel.loadNextPageZhihu();</div><div>            }</div><div>        }</div><div>    }</div><div>}</div></pre></td></tr></tbody></table></div><p>在 <code>ZhihuListFragment.java</code> 中注释已经比较清楚，关于 UI 方面的不多讲，其中最重要的一个方法是 <code>subscribeUI()</code> 方法。在该方法中，创建 ZhihuListViewModel 对象之后，对 ZhihuListViewModel 中两个重要的数据进行注册观察并更新 UI，两个重要的数据分别是：<code>LiveData&lt;List&lt;ZhihuStory&gt;&gt;</code> 和 <code>LiveData&lt;Boolean&gt;</code>：</p>
<ul>
<li><code>LiveData&lt;List&lt;ZhihuStory&gt;&gt;</code>：表示从数据层获取到的知乎列表的数据</li>
<li><code>LiveData&lt;Boolean&gt;</code>：表示是否正在获取数据的状态，以控制界面中加载动画的显示和隐藏</li>
</ul>
<h4>ViewModel 控制层</h4><p>在 <code>ZhihuListViewModel</code> 类中需要三个 LiveData 类型的属性。LiveData 类型的数据和 RxJava 中的 <code>Observables</code> 工作模式类似，当 LiveData 持有的数据发生变化时，通知观察者。如下面代码所示：</p><div><table><tbody><tr><td><pre><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div><div>33</div><div>34</div><div>35</div><div>36</div><div>37</div><div>38</div><div>39</div><div>40</div><div>41</div><div>42</div><div>43</div><div>44</div><div>45</div><div>46</div><div>47</div><div>48</div><div>49</div><div>50</div><div>51</div><div>52</div><div>53</div><div>54</div><div>55</div><div>56</div><div>57</div><div>58</div><div>59</div><div>60</div><div>61</div><div>62</div><div>63</div><div>64</div><div>65</div><div>66</div></pre></td><td><pre><div>public class ZhihuListViewModel extends AndroidViewModel {</div><div>    // 请求接口中查询的日期参数</div><div>    private MutableLiveData&lt;String&gt; mZhihuPageDate = new MutableLiveData&lt;&gt;();</div><div>    // Zhihu 列表的数据</div><div>    private final LiveData&lt;List&lt;ZhihuStory&gt;&gt; mZhihuList;</div><div>    // 是否正在进行网络请求的状态参数</div><div>    private final LiveData&lt;Boolean&gt; mIsLoadingZhihuList;</div><div>    ......</div><div>    private ZhihuListViewModel(Application application) {</div><div>        super(application);</div><div>        // 使用 Transformations.switchMap() 方法，表示当 View 改变 mZhihuPageDate 参数的值时，则进行 zhihu 列表数据的请求</div><div>        mZhihuList = Transformations.switchMap(mZhihuPageDate, new Function&lt;String, LiveData&lt;List&lt;ZhihuStory&gt;&gt;&gt;() {</div><div>            @Override</div><div>            public LiveData&lt;List&lt;ZhihuStory&gt;&gt; apply(String input) {</div><div>                ......</div><div>            }</div><div>        });</div><div>    }</div><div>    public LiveData&lt;List&lt;ZhihuStory&gt;&gt; getZhihuList() {</div><div>        return mZhihuList;</div><div>    }</div><div>    public LiveData&lt;Boolean&gt; isLoadingZhihuList() {</div><div>        return mIsLoadingZhihuList;</div><div>    }</div><div>    /**</div><div>     * 下拉刷新，获取最新的 Zhihu 列表数据</div><div>     */</div><div>    public void refreshZhihusData() {</div><div>          mZhihuPageDate.setValue(&quot;today&quot;);</div><div>    }</div><div>    /**</div><div>     * 上拉加载更多时，获取 Zhihu 历史列表数据</div><div>     *</div><div>     * @param positon 表示列表滑动到最后一项</div><div>     */</div><div>    public void loadNextPageZhihu(int positon) {</div><div>        if (!Util.isNetworkConnected(MyApplication.getInstance())) {</div><div>            return;</div><div>        }   </div><div>        mZhihuPageDate.setValue(String.valueOf(positon));</div><div>    }</div><div>    public static class Factory extends ViewModelProvider.NewInstanceFactory {</div><div>        @NonNull</div><div>        private final Application mApplication;</div><div>        public Factory(@NonNull Application application) {</div><div>            mApplication = application;</div><div>        }</div><div>        @Override</div><div>        public &lt;T extends ViewModel&gt; T create(Class&lt;T&gt; modelClass) {</div><div>            return (T) new ZhihuListViewModel(mApplication);</div><div>        }</div><div>    }</div><div>}</div></pre></td></tr></tbody></table></div><blockquote>
<p>注：由于 ViewModel 存活的时间可能会比个别的 activity 和 fragment 实例更长，所以它决不能引用 View，或任何持任何 activity(context)。如果 ViewModel 需要 Application 的 context（如：调用系统服务），可以继承 AndroidViewModel 类，可以在构造函数中接受 Application。</p>
</blockquote>
<p>上面示例的 ZhihuListViewModel 类是功能并不完整的 ViewModel 类，因为它只是向 View 层提供了操作 Zhihu 列表数据和监听数据请求状态的接口，那么 ZhihuListViewModel 该从哪里获取数据呢？换句话说，数据源在哪里？<br/>在 <a href="https://github.com/lijiankun24/ArchitecturePractice" target="_blank">ArchitecturePractice</a> 项目中，封装了 <a href="https://github.com/lijiankun24/ArchitecturePractice/blob/master/app/src/main/java/com/lijiankun24/architecturepractice/data/DataRepository.java" target="_blank">DataRepository</a> 类，表示所有数据的源头。<br/>那 ZhihuListViewModel 应该持有一个 <code>DataRepository</code> 对象，来获取数据。完整的 <code>ZhihuListViewModel</code> 类如下所示：</p><div><table><tbody><tr><td><pre><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div><div>33</div><div>34</div><div>35</div><div>36</div><div>37</div><div>38</div><div>39</div><div>40</div><div>41</div><div>42</div><div>43</div><div>44</div><div>45</div><div>46</div><div>47</div><div>48</div><div>49</div><div>50</div><div>51</div><div>52</div><div>53</div><div>54</div><div>55</div><div>56</div><div>57</div><div>58</div><div>59</div><div>60</div><div>61</div><div>62</div><div>63</div><div>64</div><div>65</div><div>66</div><div>67</div><div>68</div><div>69</div><div>70</div><div>71</div><div>72</div><div>73</div><div>74</div><div>75</div><div>76</div><div>77</div><div>78</div><div>79</div><div>80</div><div>81</div><div>82</div><div>83</div><div>84</div><div>85</div></pre></td><td><pre><div>/**</div><div> * ZhihuListViewModel.java</div><div> * &lt;p&gt;</div><div> * Created by lijiankun on 17/7/30.</div><div> */</div><div>public class ZhihuListViewModel extends AndroidViewModel {</div><div>    // 请求接口中查询的日期参数</div><div>    private MutableLiveData&lt;String&gt; mZhihuPageDate = new MutableLiveData&lt;&gt;();</div><div>    // Zhihu 列表的数据</div><div>    private final LiveData&lt;List&lt;ZhihuStory&gt;&gt; mZhihuList;</div><div>    // 数据源</div><div>    private DataRepository mDataRepository = null;</div><div>    private ZhihuListViewModel(Application application, DataRepository dataRepository) {</div><div>        super(application);</div><div>        mDataRepository = dataRepository;</div><div>        // 使用 Transformations.switchMap() 方法，当 View 改变 mZhihuPageDate 参数的值时，则进行 zhihu 列表数据的请求</div><div>        mZhihuList = Transformations.switchMap(mZhihuPageDate, new Function&lt;String, LiveData&lt;List&lt;ZhihuStory&gt;&gt;&gt;() {</div><div>            @Override</div><div>            public LiveData&lt;List&lt;ZhihuStory&gt;&gt; apply(String input) {</div><div>                return mDataRepository.getZhihuList(input);</div><div>            }</div><div>        });</div><div>    }</div><div>    /**</div><div>      * 获取 Zhihu 列表数据</div><div>      *</div><div>      * @return Zhihu 列表数据</div><div>      */</div><div>    public LiveData&lt;List&lt;ZhihuStory&gt;&gt; getZhihuList() {</div><div>        return mZhihuList;</div><div>    }</div><div>    /**</div><div>      * 数据请求状态由 DataRepository 控制，包括下拉刷新和上拉加载更多</div><div>      *</div><div>      * @return 是否在进行数据请求</div><div>      */</div><div>    public LiveData&lt;Boolean&gt; isLoadingZhihuList() {</div><div>        return mDataRepository.isLoadingZhihuList();</div><div>    }</div><div>    /**</div><div>     * 下拉刷新，获取最新的 Zhihu 列表数据</div><div>     */</div><div>    public void refreshZhihusData() {</div><div>        mZhihuPageDate.setValue(&quot;today&quot;);</div><div>    }</div><div>    /**</div><div>     * 上拉加载更多时，获取 Zhihu 历史列表数据</div><div>     *</div><div>     * @param positon 表示列表滑动到最后一项</div><div>     */</div><div>    public void loadNextPageZhihu(int positon) {</div><div>        if (!Util.isNetworkConnected(MyApplication.getInstance())) {</div><div>            return;</div><div>        }</div><div>        mZhihuPageDate.setValue(String.valueOf(positon));</div><div>    }</div><div>    public static class Factory extends ViewModelProvider.NewInstanceFactory {</div><div>        @NonNull</div><div>        private final Application mApplication;</div><div>        private final DataRepository mGirlsDataRepository;</div><div>        public Factory(@NonNull Application application, DataRepository girlsDataRepository) {</div><div>            mApplication = application;</div><div>            mGirlsDataRepository = girlsDataRepository;</div><div>        }</div><div>        @Override</div><div>        public &lt;T extends ViewModel&gt; T create(Class&lt;T&gt; modelClass) {</div><div>            return (T) new ZhihuListViewModel(mApplication, mGirlsDataRepository);</div><div>        }</div><div>    }</div><div>}</div></pre></td></tr></tbody></table></div><h4>Model 数据层</h4><p>正如在 ViewModel 控制层中介绍的，<a href="https://github.com/lijiankun24/ArchitecturePractice" target="_blank">ArchitecturePractice</a> 中所有的数据均由 <code>DataRepository</code> 类中获取。在 <code>DataRepository</code> 中有两个数据源：本地数据库和远端服务器，如果有网，则从服务器获取最新数据，并保存在本地数据库中；如果没有网，则从本地数据库中加载数据并显示。则 <code>DataRepository</code> 的初步实现是这样的：</p><div><table><tbody><tr><td><pre><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div><div>33</div><div>34</div><div>35</div><div>36</div><div>37</div><div>38</div><div>39</div><div>40</div><div>41</div><div>42</div><div>43</div><div>44</div><div>45</div><div>46</div><div>47</div><div>48</div><div>49</div><div>50</div><div>51</div><div>52</div><div>53</div><div>54</div><div>55</div><div>56</div><div>57</div><div>58</div><div>59</div><div>60</div><div>61</div><div>62</div><div>63</div></pre></td><td><pre><div>/**</div><div> * DataRepository.java</div><div> * &lt;p&gt;</div><div> * Created by lijiankun on 17/7/7.</div><div> */</div><div>public class DataRepository {</div><div>    private static DataRepository INSTANCE = null;</div><div>    // 从服务器获取数据</div><div>    private final DataSource mRemoteDataSource;</div><div>    // 从本地数据库获取数据</div><div>    private final DataSource mLocalDataSource;</div><div>    private static Application sApplication = null;</div><div>    private DataRepository(@NonNull DataSource remoteDataSource,</div><div>                           @NonNull DataSource localDataSource) {</div><div>        mRemoteDataSource = remoteDataSource;</div><div>        mLocalDataSource = localDataSource;</div><div>    }</div><div>    static DataRepository getInstance(@NonNull DataSource remoteDataSource,</div><div>                                      @NonNull DataSource localDataSource,</div><div>                                      Application application) {</div><div>        if (INSTANCE == null) {</div><div>            synchronized (DataRepository.class) {</div><div>                if (INSTANCE == null) {</div><div>                    INSTANCE = new DataRepository(remoteDataSource, localDataSource);</div><div>                    sApplication = application;</div><div>                }</div><div>            }</div><div>        }</div><div>        return INSTANCE;</div><div>    }</div><div>    public LiveData&lt;List&lt;ZhihuStory&gt;&gt; getZhihuList(@NonNull String date) {</div><div>        if (Util.isNetworkConnected(sApplication.getApplicationContext())) {</div><div>            if (date.equals(&quot;today&quot;)) {</div><div>                return mRemoteDataSource.getLastZhihuList();</div><div>            } else {</div><div>                return mRemoteDataSource.getMoreZhihuList(date);</div><div>            }</div><div>        } else {</div><div>            if (date.equals(&quot;today&quot;)) {</div><div>                return mLocalDataSource.getLastZhihuList();</div><div>            } else {</div><div>                return mLocalDataSource.getMoreZhihuList(date);</div><div>            }</div><div>        }</div><div>    }</div><div>    public LiveData&lt;Boolean&gt; isLoadingZhihuList() {</div><div>        if (Util.isNetworkConnected(sApplication.getApplicationContext())) {</div><div>            return mRemoteDataSource.isLoadingZhihuList();</div><div>        } else {</div><div>            return mLocalDataSource.isLoadingZhihuList();</div><div>        }</div><div>    }</div><div>}</div></pre></td></tr></tbody></table></div><p>其中的 <code>DataSource</code> 表示获取数据的抽象层，如下所示：</p><div><table><tbody><tr><td><pre><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div></pre></td><td><pre><div>public interface DataSource {</div><div>    ......</div><div>    /**</div><div>     * Zhihu 相关方法</div><div>     */</div><div>    LiveData&lt;List&lt;ZhihuStory&gt;&gt; getLastZhihuList();</div><div>    LiveData&lt;List&lt;ZhihuStory&gt;&gt; getMoreZhihuList(String date);</div><div>    LiveData&lt;Boolean&gt; isLoadingZhihuList();</div><div>}</div></pre></td></tr></tbody></table></div><p>此外还有两个非常重要的类：<code>RemoteDataSource</code> 和 <code>LocalDataSource</code>，这两个类分别实现了 <code>DataSource</code> 接口。<br/><code>RemoteDataSource</code> 类代码如下所示，从远端服务器获取数据使用的是 <code>Retrofit</code>，并且对网络请求进行简单封装，由 <a href="https://github.com/lijiankun24/ArchitecturePractice/blob/master/app/src/main/java/com/lijiankun24/architecturepractice/data/remote/api/ApiManager.java" target="_blank">ApiManager</a> 统一向外提供网络请求接口：</p><div><table><tbody><tr><td><pre><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div><div>33</div><div>34</div><div>35</div><div>36</div><div>37</div><div>38</div><div>39</div><div>40</div><div>41</div><div>42</div><div>43</div><div>44</div><div>45</div><div>46</div><div>47</div><div>48</div><div>49</div><div>50</div><div>51</div><div>52</div><div>53</div><div>54</div><div>55</div><div>56</div><div>57</div><div>58</div><div>59</div><div>60</div><div>61</div><div>62</div><div>63</div><div>64</div><div>65</div><div>66</div><div>67</div><div>68</div><div>69</div><div>70</div><div>71</div><div>72</div><div>73</div><div>74</div><div>75</div><div>76</div><div>77</div><div>78</div><div>79</div><div>80</div><div>81</div><div>82</div><div>83</div><div>84</div><div>85</div><div>86</div><div>87</div><div>88</div><div>89</div><div>90</div><div>91</div><div>92</div><div>93</div><div>94</div><div>95</div><div>96</div><div>97</div></pre></td><td><pre><div>/**</div><div> * RemoteDataSource.java</div><div> * &lt;p&gt;</div><div> * Created by lijiankun on 17/7/7.</div><div> */</div><div>public class RemoteDataSource implements DataSource {</div><div>    private static RemoteDataSource INSTANCE = null;</div><div>    private final MutableLiveData&lt;Boolean&gt; mIsLoadingZhihuList;</div><div>    private final MutableLiveData&lt;List&lt;ZhihuStory&gt;&gt; mZhihuList;</div><div>    private final ApiZhihu mApiZhihu;</div><div>    private String mZhihuPageDate;</div><div>    {</div><div>        mIsLoadingZhihuList = new MutableLiveData&lt;&gt;();</div><div>        mZhihuList = new MutableLiveData&lt;&gt;();</div><div>    }</div><div>    private RemoteDataSource() {</div><div>        mApiZhihu = ApiManager.getInstance().getApiZhihu();</div><div>    }</div><div>    public static RemoteDataSource getInstance() {</div><div>        if (INSTANCE == null) {</div><div>            synchronized (RemoteDataSource.class) {</div><div>                if (INSTANCE == null) {</div><div>                    INSTANCE = new RemoteDataSource();</div><div>                }</div><div>            }</div><div>        }</div><div>        return INSTANCE;</div><div>    }</div><div>    @Override</div><div>    public LiveData&lt;List&lt;ZhihuStory&gt;&gt; getLastZhihuList() {</div><div>        mIsLoadingZhihuList.setValue(true);</div><div>        mApiZhihu.getLatestNews()</div><div>                .enqueue(new Callback&lt;ZhihuData&gt;() {</div><div>                    @Override</div><div>                    public void onResponse(Call&lt;ZhihuData&gt; call, Response&lt;ZhihuData&gt; response) {</div><div>                        if (response.isSuccessful()) {</div><div>                            mZhihuList.setValue(response.body().getStories());</div><div>                            refreshLocalZhihuList(response.body().getStories());</div><div>                            mZhihuPageDate = response.body().getDate();</div><div>                        }</div><div>                        mIsLoadingZhihuList.setValue(false);</div><div>                    }</div><div>                    @Override</div><div>                    public void onFailure(Call&lt;ZhihuData&gt; call, Throwable t) {</div><div>                        mIsLoadingZhihuList.setValue(false);</div><div>                    }</div><div>                });</div><div>        return mZhihuList;</div><div>    }</div><div>    @Override</div><div>    public LiveData&lt;List&lt;ZhihuStory&gt;&gt; getMoreZhihuList(String date) {</div><div>        mIsLoadingZhihuList.setValue(true);</div><div>        mApiZhihu.getTheDaily(mZhihuPageDate)</div><div>                .enqueue(new Callback&lt;ZhihuData&gt;() {</div><div>                    @Override</div><div>                    public void onResponse(Call&lt;ZhihuData&gt; call, Response&lt;ZhihuData&gt; response) {</div><div>                        if (response.isSuccessful()) {</div><div>                            mZhihuList.setValue(response.body().getStories());</div><div>                            refreshLocalZhihuList(response.body().getStories());</div><div>                            mZhihuPageDate = response.body().getDate();</div><div>                        }</div><div>                        mIsLoadingZhihuList.setValue(false);</div><div>                    }</div><div>                    @Override</div><div>                    public void onFailure(Call&lt;ZhihuData&gt; call, Throwable t) {</div><div>                        mIsLoadingZhihuList.setValue(false);</div><div>                    }</div><div>                });</div><div>        return mZhihuList;</div><div>    }</div><div>    @Override</div><div>    public MutableLiveData&lt;Boolean&gt; isLoadingZhihuList() {</div><div>        return mIsLoadingZhihuList;</div><div>    }</div><div>    private void refreshLocalZhihuList(List&lt;ZhihuStory&gt; zhihuStoryList) {</div><div>        if (zhihuStoryList == null || zhihuStoryList.isEmpty()) {</div><div>            return;</div><div>        }</div><div>        AppDatabaseManager.getInstance().insertZhihuList(zhihuStoryList);</div><div>    }</div><div>}</div></pre></td></tr></tbody></table></div><p><code>LocalDataSource</code> 类代码如下所示，从本地数据库获取数据使用的是 Architecture Components 中的 <code>Room</code> 库，简单封装为 <a href="https://github.com/lijiankun24/ArchitecturePractice/blob/master/app/src/main/java/com/lijiankun24/architecturepractice/data/local/db/AppDatabaseManager.java" target="_blank">AppDatabaseManager</a> ，向外提供统一的方法：</p><div><table><tbody><tr><td><pre><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div><div>33</div><div>34</div><div>35</div><div>36</div><div>37</div><div>38</div><div>39</div><div>40</div><div>41</div></pre></td><td><pre><div>/**</div><div> * LocalDataSource.java</div><div> * &lt;p&gt;</div><div> * Created by lijiankun on 17/7/7.</div><div> */</div><div>public class LocalDataSource implements DataSource {</div><div>    private static LocalDataSource INSTANCE = null;</div><div>    private LocalDataSource() {</div><div>    }</div><div>    public static LocalDataSource getInstance() {</div><div>        if (INSTANCE == null) {</div><div>            synchronized (LocalDataSource.class) {</div><div>                if (INSTANCE == null) {</div><div>                    INSTANCE = new LocalDataSource();</div><div>                }</div><div>            }</div><div>        }</div><div>        return INSTANCE;</div><div>    }</div><div>    ......</div><div>    @Override</div><div>    public LiveData&lt;List&lt;ZhihuStory&gt;&gt; getLastZhihuList() {</div><div>        return AppDatabaseManager.getInstance().loadZhihuList();</div><div>    }</div><div>    @Override</div><div>    public LiveData&lt;List&lt;ZhihuStory&gt;&gt; getMoreZhihuList(String date) {</div><div>        return null;</div><div>    }</div><div>    @Override</div><div>    public LiveData&lt;Boolean&gt; isLoadingZhihuList() {</div><div>        return AppDatabaseManager.getInstance().isLoadingZhihuList();</div><div>    }</div><div>}</div></pre></td></tr></tbody></table></div><p>使用到的 <code>ApiManager</code> 用于统一管理 Retrofit 网络请求，<code>AppDatabaseManager</code> 则是对 Room 数据库的统一管理，关于 Retrofit 和 Room 的使用就不再多说。这样一个向外提供干净可靠 API 的数据源 DataRepository 模块则完成了，DataRepository 主要负责处理数据的获取。</p>
<hr/>
<p>至此，关于 Architecture Components 组件的介绍和实践都全部介绍完毕，本文中用于举例的 <a href="https://github.com/lijiankun24/ArchitecturePractice" target="_blank">ArchitecturePractice</a> 在 GitHub 上，欢迎 star 和 fork，也欢迎通过下面二维码下载 APK 体验，如果有什么问题欢迎指出。我的工作邮箱：jiankunli24@gmail.com</p>
<div>    <a href="http://lijiankun24.com/Android-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%EF%BC%88Architecture-Components%EF%BC%89%E5%AE%9E%E8%B7%B5/QR.png" target="_blank"><div><img src="Android 应用架构组件（Architecture Components）实践_files/Image [2].png" type="image/png" data-filename="" height="340" width="336"/></div></a></div><p><strong>参考资料：</strong></p>
<p><a href="https://developer.android.com/topic/libraries/architecture/index.html" target="_blank">Android Architecture Components 官方文档</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/27026614" target="_blank">Google 官方推出应用开发架构指南</a>  – <a href="https://www.zhihu.com/people/hev1n/posts" target="_blank">Hevin</a></p>
<p><a href="https://juejin.im/post/5937b1d7a22b9d005810b877" target="_blank">译 Architecture Components 之 Guide to App Architecture</a> – <a href="https://juejin.im/user/55f6932f60b2a6fc10c88843" target="_blank">zly394</a></p>

      
    </div>

    

    

    

    
  </div></div></div><br/></div></span>
</div></body></html> 