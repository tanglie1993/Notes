<html>
<head>
  <title>安卓中的Flux架构 - 泡在网上的日子</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/305825 (zh-CN, DDL); Windows/10.0.15063 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="2152"/>
<h1>安卓中的Flux架构 - 泡在网上的日子</h1>

<div><span><div style="-evernote-webclip:true"><br/><div><div><div><div><h1>今天: Clean Architecture</h1><div><div></div></div></div><p>目前的趋势是采用Uncle Bob在2012年对web应用提出的建议： <a href="https://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank">Clean Architecture</a>。</p><p>但是我发现Clean Architecture对于绝大多数安卓应用来说都有点过度设计了。</p><p>通常移动应用要比web应用的生命短。移动端技术的发展太快，以至于今天发行的app可能在一年后已经完全过时。</p><p>移动应用所做的事情很少。绝大多数的用例都只是数据信息流的消费。从API获取数据，显示数据给用户，很少有输入与写入。</p><p>所以它的业务逻辑并不复杂。至少不如后端一样的复杂。虽然你要处理很多平台上的问题：内存，存储，暂停，恢复，网络，定位等等，但是这些都不是业务逻辑。所有app都有这些东西。</p><p>因此，绝大多数app似乎都无法从类似于复杂的分层或者工作执行优先级队列中获益。</p><p>他们也许只是需要一种组织代码的简单方式，能高效的一起工作，更容易的发现bug。</p><h1>Flux 架构介绍</h1><p><a href="https://facebook.github.io/flux/docs/overview.html" target="_blank">Flux 架构</a> 被Facebook使用来构建他们的客户端web应用。跟Clean Architecture一样，它不是为移动应用设计的，但是它的特性和简单可以让我们很好的在安卓项目中采用。</p><p></p><div><img src="安卓中的Flux架构 - 泡在网上的日子_files/Image.png" type="image/png" data-filename="" alt="flux-graph-simple" height="257" width="576"/></div><p></p><p>要理解Flux，有两个关键的特点</p><ul><li><p>数据流总是单向的</p><p>一个<a href="https://www.youtube.com/watch?v=i__969noyAM" target="_blank">单向的数据流</a> 是 Flux 架构的核心，也是它简单易学的原因。就如下面讨论的，在进行应用测试的时候，它提供了非常大的帮助。</p></li><li><p>应用被分成三个主要部分：</p></li><ul><li><p><strong>View</strong>: 应用的界面。这里创建响应用户操作的action。</p></li><li><p><strong>Dispatcher</strong>: 中心枢纽，传递所有的action，负责把它们运达每个Store。</p></li><li><p><strong>Store</strong>: 维护一个特定application domain的状态。它们根据当前状态响应action，执行业务逻辑，同时在完成的时候发出一个change事件。这个事件用于view更新其界面。</p></li></ul></ul><p>这三个部分都是通过Action来通信的：一个简单的基本对象，以类型来区分，包含了和操作相关的数据。</p><h1>Flux Android 架构</h1><p>在安卓开发中使用Flux设计规范的目的是建立一个在简单性与易扩展易测试之间都比较平衡的架构。</p><p>第一步是找到Flux元素和安卓app组件之间的映射。</p><p>其中两个元素非常容易找到与实现。</p><ul><li><p>View: Activity o或者Fragment</p></li><li><p>Dispatcher: 一个事件总线（ event bus），在我的例子中将使用Otto，但是其它任何实现都应该是ok的。 </p></li></ul><h2>Actions</h2><p>Actions也不复杂。它们的实现和POJO一样简单，有两个主要属性：</p><ul><li><p>Type: 一个String，定义了事件的类型。</p></li><li><p>Data: 一个map，装载了本次操作。</p></li></ul><p>比如，一个显示用户详情的典型action如下：</p><pre>Bundle data = new Bundle(); 
data.put(&quot;USER_ID&quot;, id); 
Action action = new ViewAction(&quot;SHOW_USER&quot;, data);</pre><h2>Stores</h2><p>这可能是Flux理论中最难的部分。</p><p>如果你之前使用过Clean Architecture，你可能难以接受。因为Stores承担了原本被分成多层的责任。</p><p>Stores包含了application的状态与它的业务逻辑。它们类似于rich data models但是可以管理多个对象的状态，而不仅仅是一个对象。</p><p>Stores响应Dispatcher发出的Action，执行业务逻辑并发送change事件。</p><p>Stores的唯一输出是这单一的事件：change。其它对Store内部状态感兴趣的组件必须监听这个事件，同时使用它获取需要的数据。</p><p>系统中不再需要任何其它组建去了解application的任何状态信息。</p><p>最后，stores必须对外公开一个获取application状态的接口。这样，view元素可以查询Stores然后相应的更新UI。</p><p></p><div><img src="安卓中的Flux架构 - 泡在网上的日子_files/Image [1].png" type="image/png" data-filename="" alt="flux-graph-store" height="270" width="576"/></div><p></p><p>比如，在一个Pub Discovery App 中，SearchStore被用来跟踪被搜索的item，搜索结果以及搜索历史。在同一个应用中，一个ReviewedStore同样包含了浏览pub的列表以及必要的逻辑比如根据review排序。</p><p>但是有一个重要的概念需要记住：Stores并不是仓库。它们的职责不是从一个外部源（API或者数据库）获取数据，而是跟踪actions提供的数据。</p><p>那么，Flux application是如何获得数据的呢？</p><h2>网络请求与异步调用</h2><p>在第一幅Flux示意图中我有意跳过了一部分：网络调用。接下来的示意图完善第一幅图并添加了更多细节：</p><p></p><div><img src="安卓中的Flux架构 - 泡在网上的日子_files/Image [2].png" type="image/png" data-filename="" alt="flux-graph-complete" height="321" width="576"/></div><p></p><p>异步网络调用是被一个Actions Creator触发的。一个Network 适配器完成相应API的异步调用并且返回结果给Actions Creator。</p><p>最终Actions Creator分发带有返回数据的相应类型的Action。</p><p>把所有网络工作和异步工作独立于Stores之外有两个主要的优点：</p><ul><li><p>你的Stores是完全同步的：这让Store中的逻辑更容易跟踪。Bug也更容易跟踪。同时，因为所有的状态变化都是同步的，那么Store的测试变会的非常简单：启动actions然后等待期望的结果。</p></li><li><p>所有的action都是从一个Action Creator触发的：在一处单一的点创建与发起所有用户操作可以大大简化寻找错误的过程。忘掉在多个类中寻找某个操作的源头吧 ，所有的事情都是在这里发生的。同时，因为异步调用发生在这之前，所有来自于ActionCreator的东西都是同步的。这大大提高了代码的可跟踪与可测试性。</p></li></ul><h1>演示代码：To－Do应用</h1><p><a href="https://github.com/lgvalle/android-flux-todo-app" target="_blank">在这个例子中</a>，你将看到一个使用Flux架构的典型的To-Do应用。</p><p>我让项目尽量简单，只演示这个架构如何能够产生组织良好的app。</p><p>对于实现的一些评价：</p><ul><li><p>Dispatcher的实现是通过Otto Bus。但是几乎任何bus都是可以的。Flux架构本身在事件上有一定限制，我在这里没有采用。原本Flux的定义中，前一个事件没有完成之前就开始分发下一个事件是不允许的，会抛出一个异常。为了让项目简单，我没有采用。</p></li><li><p>有一个ActionsCreator类帮助创建Action，并把它们post给Dispatcher。这在Flux中时相当普遍的模式，可以让事情变的有序。</p></li><li><p>Actions类型只是String常量。也许这不是最好的实现，但是它快速并且有助于事情的简单化。</p></li></ul><p>同样的还有Actions数据：它们只是以String类型为key，Object为值的HashMap。这会导致Stores中转换成实际数据的时候发生丑陋的类型转换。而且显然这也不是类型安全的，但这也是为了让我们的例子更好理解。</p><p>在安卓应用中<strong>其实不存在最佳架构的说法</strong>。不过存在适合你当前app的最佳架构。这个架构可以让你和团队其他成员协作起来更轻松，按时完成项目，尽可能的保持高质量与较少的bug。</p><p>我相信Flux对于以上提到的特点都有很好的支持。</p><p><a href="https://github.com/lgvalle/android-flux-todo-app" target="_blank">https://github.com/lgvalle/android-flux-todo-app</a></p><h1>扩展阅读:</h1><p>特别感谢我们的同事<a href="https://twitter.com/MicheleBertoli" target="_blank">Michele Bertoli</a> 花时间向我介绍Flux与校对这篇文章。</p>
				</div></div></div><br/></div></span>
</div></body></html> 