<html>
<head>
  <title>Android存储挖坑记</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/305825 (zh-CN, DDL); Windows/10.0.15063 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1784"/>
<h1>Android存储挖坑记</h1>

<div><span><div style="-evernote-webclip:true"><br/><div><div><div><div><h1> Android存储挖坑记 </h1><div><div></div></div></div>
                    <div>
                                                
                        						                        <em>2016-05-04</em>

                                                <em>姚家艺</em>
                                                <a href="#" target="_blank">Android程序员</a>
                        

                        
                    </div>
                    
                    
                    
                    
                                                            
                                                            
                    
                    
                        
                        <blockquote><p>声明：本文由作者授权在 Android程序员 公众号原创发布。</p><p>作者：姚家艺</p><p>原文：http://blog.desmondyao.com/2016/05/04/android-storage/</p></blockquote><blockquote><p>昨天的文章 <a href="http://mp.weixin.qq.com/s?__biz=MzA4MjU5NTY0NA==&amp;mid=2653418627&amp;idx=1&amp;sn=4087d70a0da7754774ff83e7abc8c2c7&amp;scene=21#wechat_redirect" target="_blank">关于原创，我不得不说</a> 得到了很多同学的支持，除了给我留言的同学，不少人在后台给我发消息，才知道有许多潜水的同学一直在默默支持我，让我非常感动，也深受鼓励，因为我性格的原因，并不是很擅长与读者之间地更多互动，有时候发文虽然很多人阅读，但留言的并不多，但其实知道大家都有在默默关注，也足够了，我更希望的是文章能被更多人传阅，对我与作者都是一份鼓励，大家如果觉得文章有帮助，不妨让更多人也看到，这也算是对我最大的支持了。</p><p>五一后的第一次技术文章推送，来自姚家艺同学，这篇文章对目前Android存储相关的知识进行了一些梳理，文章不长但相信对各位会有一些帮助，学习往往都是一个个小知识点的逐个吃透。早前也曾给大家推荐过家艺的 <a href="http://mp.weixin.qq.com/s?__biz=MzA4MjU5NTY0NA==&amp;mid=404147665&amp;idx=1&amp;sn=a16153b2a658db64ab80926cd3b76447&amp;scene=21#wechat_redirect" target="_blank">Butter Knife 源码解析</a> 一文，没看过的同学也可以移步查看。</p></blockquote><p>最近在搞Android存储相关的业务，什么Internal/External/Primary/Secondary搞得我都看懵了，国内也没什么好的文章系统的讲这个，我就挖挖各类资料，整理一下。</p><h2>1. Internal vs External</h2><p>对于Internal Storage 与 External Storage，官方文档上有这么一段话，描述得很详细了，我翻译了一段下来：</p><blockquote><p>所有的Android设备都有两块存储区域：Internal Storage和External Storage。它们的名称来源于早期的Android系统，那时候大家的手机都内置(Permanent)一块较小存储板（即Internal Storage），并配上一个的外置的(Removable)储存卡（即External Storage）。后来部分手机开始将最初定义的“Internal Storage”，即内置存储，分成Internal和External两部分。这样一来就算没有外置储存，手机也有Internal和External两块存储区域。这两块存储区域的区别是：</p><table><thead><tr><th>Internal Storage</th><th>External Storage</th></tr></thead><tbody><tr><td>可信度</td><td>永远可用(Permanent)</td><td>可能不可用，最典型的当设备作为USB存储被mount时不可用</td></tr><tr><td>访问权限</td><td>App存储内容仅App本身（或共享uid的App）可访问（Root除外）</td><td>App存储内容全局可读</td></tr><tr><td>内容持久</td><td>App存储内容随App卸载而消失</td><td>当App卸载时，只有存在<code>getExternalFilesDir()</code>路径下的文件会消失</td></tr><tr><td>适应情况</td><td>存储内容仅App自己访问时的最佳选择</td><td>存储内容希望与其他App共享或传到电脑上，但是不想申请任何权限时的最佳选择</td></tr></tbody></table><p>注：此处讨论的访问权限是应用路径下的权限。</p></blockquote><p>总结下来，External存储区域有几个好处：</p><ol><li><p>可以传到电脑上；</p></li><li><p>可以与其他app共享；</p></li><li><p>在4.4之后的App路径(<code>Android/data/包名</code>)下读写不需任何权限；</p></li><li><p>存在App路径之外的文件不会随App卸载。</p></li></ol><p>相应的，也有几个缺点：</p><ol><li><p>可能不可用；</p></li><li><p>会被其他应用读到;</p></li><li><p>在非App路径下写、修改文件需要权限。</p></li></ol><h3>1.1 External Storage的权限</h3><p>在Internal Storage的App路径下（<code>/data/data/包名</code>下)，App的读写操作无需任何权限，我们只需要总结一下External Storage的情况：</p><table><thead><tr><th>Android版本</th><th>读</th><th>写</th></tr></thead><tbody><tr><td>4.4以下</td><td>无需权限</td><td>需要申请<code>WRITE_EXTERNAL_STORAGE</code></td></tr><tr><td>4.4及以上</td><td>无需权限</td><td>在App目录之外写，需要申请<code>WRITE_EXTERNAL_STORAGE</code></td></tr></tbody></table><p>关于读External的权限，在<a target="_blank">Android Developer</a>上有这样一段话:</p><blockquote><p>目前，所有App都可以读External存储而不需要任何权限，这一点可能会在未来做出改变。如果你希望读External存储，那最好申请一下<code>READ_EXTERNAL_STORAGE</code>权限。另外，写权限已经默认包含了读权限了。</p></blockquote><p>正常情况下，你用任何文件管理器，点开的根目录就是你的External存储。你可以到它下面的应用目录，你会发现，就算是各个包名下的文件，你也是看得到的。</p><h3>1.2 多用户</h3><p>在4.2及以上的Android系统中引入了多用户机制。你可能会发现在存储路径后面有’0’/‘1’的字样（如<code>/storage/emulated/0/</code>），这后面的数字表示用户。主用户后面为0。</p><h2>2. Primary vs Secondary</h2><p>这个Primary和Secondary是怎么来的呢？实际上最开始Android也没有考虑这个区分，但是后来有一个情况发生了，就是上面所说到的：</p><blockquote><p>后来部分手机开始将最初定义的“Internal Storage”，即内置存储，分成Internal和External两部分。</p></blockquote><p>那么如果这个时候手机再插入sd卡，那不是有多个External Storage了吗？</p><p>这个时候，从Internal Storage里面分出来的那块“External Storage”我们称之为<strong>主存储(Primary Storage)</strong>，插入的外置储存称之为<strong>副存储(Secondary Storage)</strong>。</p><p><strong>主存储路径</strong>的获取方式非常简单，可以通过<code>Environment.getExternalStorageDirectory()</code>或者<code>Context.getExternalFilesDir(null)</code>来获取。</p><p><strong>副存储路径</strong>在4.4及以上的Android系统中，可以使用<code>Context.getExternalFilesDirs(null)</code>(注意最后多了一个’s’)，它返回的是一个字符串数组。第0个就是主存储路径，第1个是副存储路径（如果有的话）。</p><p>在<strong>4.4及以下系统中</strong>，的副存储的获取方式就是一个<strong><em>大坑</em></strong>了，一个一个介绍一下笔者看到过的方法。</p><h3>2.1 副储存路径-StorageManager</h3><p>在Android中可以通过<code>context.getSystemService(STORAGE_SERVICE)</code>来获取到<code>StorageManager</code>，但是很可惜的是，它里面有价值的方法都是hide的。</p><p>庆幸的是还有反射。我们可以调用<code>getVolumeList()</code>函数，这个返回的List里面，主存储是第0个，副存储（如果有的话）是第1个。</p><p>你可以看到<code>Environment.getExternalStorageDirectory()</code>里面就是用它实现的，可以说这个方法是目前最稳妥的。它通过系统的<code>MountService</code>来获取已mount上来的设备，并且能够通过<code>StorageVolume</code>知道该存储是否<code>removable</code>、是否是<code>emulated</code>、mount状态等等。</p><p>涉及到存储，由于Android rom千奇百怪，不可能是万全的。如果反射出来的方法缺少变量、方法，或者有别的什么坑，那只能试一下其他方法来保底。</p><p><strong>靠谱程度：99%</strong></p><h3>2.2 副存储路径-读配置xml</h3><p>读<code>com.android.internal.R.xml.storage_list.xml</code>可以获取到系统的VolumeList，但是这种方法是行不通的，我们可以从源码中看看。</p><p>在6.0以前的<code>MountService</code>上面看到<code>readStorageList()</code>这个函数，它在构造函数里面就会被调用，就是在读取这个xml文件。但是我们可以看到它并没有在<code>Volume</code>改变的时候被动态写入。</p><p>并且参考<a target="_blank">AOSP Document</a>,这个xml文件里面存储的就是厂商配置的分区，它<strong>根本无法更新removable存储的热插拔信息</strong>。</p><blockquote><p>注意：<strong>这个xml在6.0被移除了(参考<a target="_blank">AOSP Document</a>)</strong></p></blockquote><p><strong>靠谱程度：0%</strong></p><h3>2.3 副存储路径-mount命令</h3><p>执行Linux shell下的mount命令，遍历每个mount点，从中找到副存储。</p><p>目前，它确实能够列出副存储。但是同时会列出很多很多mount点，包括系统mount点，目前好像没有已知的靠谱方法能够从中准确找出副存储。副存储的命名是没有规律的，枚举排除系统mount点的方法不能够100%确保准确性。</p><p><strong>靠谱程度：10%</strong></p><h3>2.4 副存储路径-读vold.fstab文件</h3><p>解析<code>/etc/void.fstab</code>，从中找到副存储位置。</p><p><strong>Vold(Volume Daemon)</strong>是<code>ServiceManager</code>与kernel层之间的桥梁，它对于Volume的信息维护在<code>/etc/vold.fstab</code>中。</p><p>一听就是一个奇怪的方法，文件位置、信息也可能被各类厂商篡改，还可能存在瞬时不一致的情况，不要考虑它。有兴趣的同学可以研究一下<a target="_blank">android-storage-vold</a>。</p><p><strong>靠谱程度：0%</strong></p><p>总结出Android手机目前的几种存储方式：</p><h3>在6.0之前</h3><p>6.0之前，所有的存储类型都是<a target="_blank">Traditional Storage</a>。它支持多用户、模拟External存储。由于是MBR分区，存储上线为2TB。</p><ol><li><p><strong>Physical Primary</strong> 最原始的样子是只有机身自带的Internal存储和以External存在的外置存储，这时候只有一个主存储，并且它是Physical的。</p></li><li><p><strong>Emulated Primary (Optional Physical Secondary)</strong> 之前所说，从Internal Storage分出一块来给External Storage。这块存储空间就是在Permanent存储版中”模拟“上去的。所以你可以看到主存储经常有<code>emulated</code>字样。 如果这时候还能再插SD卡，则会多一个Physical的Secondary存储。</p></li></ol><h3>在6.0之后</h3><p>正常情况下，它的存储方式与之前的两种相同，不过多了一种新的存储方式：<a target="_blank">Adoptable Storage</a></p><h4>Adoptable Storage</h4><p>由于External Storage的缺点（有时不可用，存储内容没有被保护），在6.0之后多出了<code>Adoptable</code>存储方式。</p><p>当Android系统<code>Adopt</code>了一块External存储区域的时候，它会被视为Internal Storage，同时会被格式化与加密。格式化之后是GPT分区，存储上线为9ZB。</p><p>当你在一个支持<code>Adoptable Storage</code>的手机上插入一个sd卡，它会提示你是否将这个sd卡格式化并用作Internal Storage，或者正常作为External Storage使用。</p><p>推荐一篇文章：<br/>CommonsWare’s post，从不同角度诠释了Internal&amp;External Storage， 非常不错！</p><blockquote><p>https://commonsware.com/blog/2014/04/07/storage-situation-internal-storage.html</p></blockquote><p>因微信平台限制，文中外链不可点击，有兴趣的同学可点击阅读原文查阅。</p>
                    </div></div></div><br/></div></span>
</div></body></html> 