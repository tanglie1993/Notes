<html>
<head>
  <title>Java 内存分配全面浅析</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/305825 (zh-CN, DDL); Windows/10.0.15063 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1874"/>
<h1>Java 内存分配全面浅析</h1>

<div>
<span><div style="-evernote-webclip:true"><br/></div><div><div><h1>Java 内存分配全面浅析</h1></div><div><em>2016-05-17</em> <em>高老大</em> <a target="_blank">android高心星的私塾</a></div><div><img src="Java 内存分配全面浅析_files/0.gif" type="image/gif" data-filename="0.gif" height="195" style="height: auto;" width="576"/></div><p>本文将由浅入深详细介绍Java内存分配的原理，以帮助新手更轻松的学习Java。这类文章网上有很多，但大多比较零碎。本文从认知过程角度出发，将带给读者一个系统的介绍。</p><p>进入正题前首先要知道的是Java程序运行在JVM(Java Virtual Machine，Java虚拟机)上，可以把JVM理解成Java程序和操作系统之间的桥梁，JVM实现了Java的平台无关性，由此可见JVM的重要性。所以在学习Java内存分配原理的时候一定要牢记这一切都是在JVM中进行的，JVM是内存分配原理的基础与前提。</p><p><strong>简单通俗的讲，一个完整的Java程序运行过程会涉及以下内存区域：</strong></p><p>l <strong>：</strong>JVM内部虚拟寄存器，存取速度非常快，程序不可控制。</p><p>l <strong>：</strong>保存局部变量的值，包括：1.用来保存基本数据类型的值；2.保存类的<strong>实例</strong>，即堆区<strong>对象</strong>的引用(指针)。也可以用来保存加载方法时的帧。</p><p>l <strong>：</strong>用来存放动态产生的数据，比如new出来的<strong>对象</strong>。注意创建出来的对象只包含属于各自的成员变量，并不包括成员方法。因为同一个类的对象拥有各自的成员变量，存储在各自的堆中，但是他们共享该类的方法，并不是每创建一个对象就把成员方法复制一次。</p><p>l <strong>：</strong>JVM为每个已加载的类型维护一个常量池，常量池就是这个类型用到的常量的一个有序集合。包括直接常量(基本类型，String)和对其他类型、方法、字段的<strong>符号引用(1)</strong>。池中的数据和数组一样通过索引访问。由于常量池包含了一个类型所有的对其他类型、方法、字段的符号引用，所以常量池在Java的动态链接中起了核心作用。<strong>常量池存在于堆中</strong>。</p><p>l <strong>：</strong>用来存放从硬盘上读取的源程序代码。</p><p>l <strong>：</strong>用来存放static定义的静态成员。</p><p><strong>下面是内存表示图：</strong></p></div><div><img src="Java 内存分配全面浅析_files/Image.png" type="image/png" data-filename="" style="height: auto;"/></div><div><p>上图中大致描述了Java内存分配，接下来通过实例详细讲解Java程序是如何在内存中运行的（注：以下图片引用自尚学堂马士兵老师的J2SE课件，图右侧是程序代码，左侧是内存分配示意图，我会一一加上注释）。</p><p><strong>预备知识：</strong></p><p><strong>1.</strong>一个Java文件，只要有main入口方法，我们就认为这是一个Java程序，可以单独编译运行。</p></div><div><strong>2.</strong>无论是普通类型的变量还是引用类型的变量(俗称实例)，都可以作为局部变量，他们都可以出现在栈中。只不过普通类型的变量在栈中直接保存它所对应的值，而引用类型的变量保存的是一个指向堆区的指针，通过这个指针，就可以找到这个实例在堆区对应的对象。因此，普通类型变量只在栈区占用一块内存，而引用类型变量要在栈区和堆区各占一块内存。</div><div><strong>示例：</strong></div><div><img src="Java 内存分配全面浅析_files/Image [1].png" type="image/png" data-filename="" style="height: auto;"/></div><div><p><strong>1.</strong>JVM自动寻找main方法，执行第一句代码，创建一个Test类的实例，在栈中分配一块内存，存放一个指向堆区对象的指针110925。</p></div><div><strong>2.</strong>创建一个int型的变量date，由于是基本类型，直接在栈中存放date对应的值9。</div><div><strong>3.</strong>创建两个BirthDate类的实例d1、d2，在栈中分别存放了对应的指针指向各自的对象。他们在实例化时调用了有参数的构造方法，因此对象中有自定义初始值。</div><div><img src="Java 内存分配全面浅析_files/Image [2].png" type="image/png" data-filename="" style="height: auto;"/></div><div>调用test对象的change1方法，并且以date为参数。JVM读到这段代码时，检测到i是局部变量，因此会把i放在栈中，并且把date的值赋给i。</div><div><img src="Java 内存分配全面浅析_files/Image [3].png" type="image/png" data-filename="" style="height: auto;"/></div><div>把1234赋给i。很简单的一步。</div><div><img src="Java 内存分配全面浅析_files/Image [4].png" type="image/png" data-filename="" style="height: auto;"/></div><div>change1方法执行完毕，立即释放局部变量i所占用的栈空间。</div><div><img src="Java 内存分配全面浅析_files/Image [5].png" type="image/png" data-filename="" style="height: auto;"/></div><div>调用test对象的change2方法，以实例d1为参数。JVM检测到change2方法中的b参数为局部变量，立即加入到栈中，由于是引用类型的变量，所以b中保存的是d1中的指针，此时b和d1指向同一个堆中的对象。在b和d1之间传递是指针。</div><div><img src="Java 内存分配全面浅析_files/Image [6].png" type="image/png" data-filename="" style="height: auto;"/></div><div>change2方法中又实例化了一个BirthDate对象，并且赋给b。在内部执行过程是：在堆区new了一个对象，并且把该对象的指针保存在栈中的b对应空间，此时实例b不再指向实例d1所指向的对象，但是实例d1所指向的对象并无变化，这样无法对d1造成任何影响。</div><div><img src="Java 内存分配全面浅析_files/Image [7].png" type="image/png" data-filename="" style="height: auto;"/></div><div>change2方法执行完毕，立即释放局部引用变量b所占的栈空间，注意只是释放了栈空间，堆空间要等待自动回收。</div><div><img src="Java 内存分配全面浅析_files/Image [8].png" type="image/png" data-filename="" style="height: auto;"/></div><div>调用test实例的change3方法，以实例d2为参数。同理，JVM会在栈中为局部引用变量b分配空间，并且把d2中的指针存放在b中，此时d2和b指向同一个对象。再调用实例b的setDay方法，其实就是调用d2指向的对象的setDay方法。</div><div><img src="Java 内存分配全面浅析_files/Image [9].png" type="image/png" data-filename=""/></div><div><p>调用实例b的setDay方法会影响d2，因为二者指向的是同一个对象。</p><p>change3方法执行完毕，立即释放局部引用变量b。</p><p>以上就是Java程序运行时内存分配的大致情况。其实也没什么，掌握了思想就很简单了。无非就是两种类型的变量：基本类型和引用类型。二者作为局部变量，都放在栈中，基本类型直接在栈中保存值，引用类型只保存一个指向堆区的指针，真正的对象在堆里。作为参数时基本类型就直接传值，引用类型传指针。</p><p><strong>小结</strong><strong>：</strong></p><p><strong>1.</strong>分清什么是实例什么是对象。Class a= new Class();此时a叫实例，而不能说a是对象。实例在栈中，对象在堆中，操作实例实际上是通过实例的指针间接操作对象。多个实例可以指向同一个对象。</p><p><strong>2.</strong>栈中的数据和堆中的数据销毁并不是同步的。方法一旦结束，栈中的局部变量立即销毁，但是堆中对象不一定销毁。因为可能有其他变量也指向了这个对象，直到栈中没有变量指向堆中的对象时，它才销毁，而且还不是马上销毁，要等垃圾回收扫描时才可以被销毁。</p><p><strong>3.</strong>以上的栈、堆、代码段、数据段等等都是相对于应用程序而言的。每一个应用程序都对应唯一的一个JVM实例，每一个JVM实例都有自己的内存区域，互不影响。并且这些内存区域是所有线程共享的。这里提到的栈和堆都是整体上的概念，这些堆栈还可以细分。</p><p><strong>4.</strong>类的成员变量在不同对象中各不相同，都有自己的存储空间(成员变量在堆中的对象中)。而类的方法却是该类的所有对象共享的，只有一套，对象使用方法的时候方法才被压入栈，方法不使用则不占用内存。</p><hr/><div><img src="Java 内存分配全面浅析_files/640.webp" type="image/webp" data-filename="640.webp"/></div></div><div style="-evernote-webclip:true"><br/></div></span>
</div></body></html> 