<html>
<head>
  <title>Android性能优化典范（二）-CSDN.NET</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/305825 (zh-CN, DDL); Windows/10.0.15063 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1514"/>
<h1>Android性能优化典范（二）-CSDN.NET</h1>

<div><span><div style="-evernote-webclip:true"><br/><div><div><div><div><h1>Android性能优化典范（二）</h1><div><div></div></div></div>
				
				
				<div>
					
				<strong>摘要：</strong>Google于不久前发布了Android性能优化典范第2季课程，共有20个短视频，内容涵盖电量优化、Android Wear上如何做优化、LRU Cache、Bitmap的缩放、提升设置alpha之后View的渲染性能等。本文是对这些课程的总结摘要。				</div>
				
				<p><b>15) Smaller PNG Files</b></p><p>尽量减少PNG图片的大小是Android里面很重要的一条规范。相比起JPEG，PNG能够提供更加清晰无损的图片，但是PNG格式的图片会更大，占用更多的磁盘空间。到底是使用PNG还是JPEG，需要设计师仔细衡量，对于那些使用JPEG就可以达到视觉效果的，可以考虑采用JPEG即可。我们可以通过Google搜索到很多关于PNG压缩的工具，如下图所示：</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407e017f400.jpg" type="image/jpeg" data-filename="55407e017f400.jpg" height="226" width="409"/></div><p></p><p>这里要介绍一种新的图片格式：Webp，它是由Google推出的一种既保留png格式的优点，又能够减少图片大小的一种新型图片格式。关于Webp的更多细节，请点击<a href="https://developers.google.com/speed/webp/?csw=1" target="_blank">这里</a>。</p><p><b>16) Pre-scaling Bitmaps</b></p><p>对bitmap做缩放，这也是Android里面最遇到的问题。对bitmap做缩放的意义很明显，提示显示性能，避免分配不必要的内存。Android提供了现成的bitmap缩放的API，叫做createScaledBitmap()，使用这个方法可以获取到一张经过缩放的图片。</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407e3167ef5.jpg" type="image/jpeg" data-filename="55407e3167ef5.jpg" height="319" width="440"/></div><p></p><p>上面的方法能够快速的得到一张经过缩放的图片，可是这个方法能够执行的前提是，原图片需要事先加载到内存中，如果原图片过大，很可能导致OOM。下面介绍其他几种缩放图片的方式。</p><p>inSampleSize能够等比的缩放显示图片，同时还避免了需要先把原图加载进内存的缺点。我们会使用类似像下面一样的方法来缩放bitmap：</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407e4bc5e7b.jpg" type="image/jpeg" data-filename="55407e4bc5e7b.jpg" height="100" width="468"/></div><p></p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407e65a85ab.jpg" type="image/jpeg" data-filename="55407e65a85ab.jpg" height="346" width="450"/></div><p></p><p>另外，我们还可以使用inScaled，inDensity，inTargetDensity的属性来对解码图片做处理，源码如下图所示：</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407e791c6f3.jpg" type="image/jpeg" data-filename="55407e791c6f3.jpg" height="375" width="484"/></div><p></p><p>还有一个经常使用到的技巧是inJustDecodeBounds，使用这个属性去尝试解码图片，可以事先获取到图片的大小而不至于占用什么内存。如下图所示：</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407e8df1955.jpg" type="image/jpeg" data-filename="55407e8df1955.jpg" height="169" width="352"/></div><p></p><p><b>17) Re-using Bitmaps</b></p><p>我们知道bitmap会占用大量的内存空间，这节会讲解什么是inBitmap属性，如何利用这个属性来提升bitmap的循环效率。前面我们介绍过使用对象池的技术来解决对象频繁创建再回收的效率问题，使用这种方法，bitmap占用的内存空间会差不多是恒定的数值，每次新创建出来的bitmap都会需要占用一块单独的内存区域，如下图所示：</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407eab9e97c.jpg" type="image/jpeg" data-filename="55407eab9e97c.jpg" height="418" width="447"/></div><p></p><p>为了解决上图所示的效率问题，Android在解码图片的时候引进了inBitmap属性，使用这个属性可以得到下图所示的效果：</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407ed7127ed.jpg" type="image/jpeg" data-filename="55407ed7127ed.jpg" height="399" width="444"/></div><p></p><p>使用inBitmap属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的bitmap会尝试去使用之前那张bitmap在heap中所占据的pixel data内存区域，而不是去问内存重新申请一块区域来存放bitmap。利用这种特性，即使是上千张的图片，也只会仅仅只需要占用屏幕所能够显示的图片数量的内存大小。下面是如何使用inBitmap的代码示例：</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407eef1e2c7.jpg" type="image/jpeg" data-filename="55407eef1e2c7.jpg" height="143" width="461"/></div><p></p><p>使用inBitmap需要注意几个限制条件：</p><ul><li>在SDK 11 -&gt; 18之间，重用的bitmap大小必须是一致的，例如给inBitmap赋值的图片大小为100-100，那么新申请的bitmap必须也为100-100才能够被重用。从SDK 19开始，新申请的bitmap大小必须小于或者等于已经赋值过的bitmap大小。</li><li>新申请的bitmap与旧的bitmap必须有相同的解码格式，例如大家都是8888的，如果前面的bitmap是8888，那么就不能支持4444与565格式的bitmap了。</li></ul><p>我们可以创建一个包含多种典型可重用bitmap的对象池，这样后续的bitmap创建都能够找到合适的“模板”去进行重用。如下图所示：</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407f0e95308.jpg" type="image/jpeg" data-filename="55407f0e95308.jpg" height="325" width="403"/></div><p></p><p>Google介绍了一个开源的加载bitmap的库：<a href="https://github.com/bumptech/glide" target="_blank">Glide</a>，这里面包含了各种对bitmap的优化技巧。</p><p><b>18) The Performance Lifecycle</b></p><p>大多数开发者在没有发现严重性能问题之前是不会特别花精力去关注性能优化的，通常大家关注的都是功能是否实现。当性能问题真的出现的时候，请不要慌乱。我们通常采用下面三个步骤来解决性能问题。</p><ul><li>Gather：收集数据</li></ul><p>我们可以通过Android SDK里面提供的诸多工具来收集CPU、GPU、内存、电量等性能数据。</p><ul><li>Insight：分析数据</li></ul><p>通过上面的步骤，我们获取到了大量的数据，下一步就是分析这些数据。工具帮我们生成了很多可读性强的表格，我们需要事先了解如何查看表格的数据，每一项代表的含义，这样才能够快速定位问题。如果分析数据之后还是没有找到问题，那么就只能不停的重新收集数据，再进行分析，如此循环。</p><ul><li>Action：解决问题</li></ul><p>定位到问题之后，我们需要采取行动来解决问题。解决问题之前一定要先有个计划，评估这个解决方案是否可行，是否能够及时的解决问题。</p><p><b>19) Tools not Rules</b></p><p>虽然前面介绍了很多调试的方法，处理技巧，规范建议等等，可是这并不意味着所有的情况都适用，我们还是需要根据当时的情景做特定灵活的处理。</p><p><b>20) Memory Profiling 101</b></p><p>围绕Android生态系统，不仅仅有Phone、还有Wear、TV、Auto等。对这些不同形态的程序进行性能优化，都离不开内存调试这个步骤。这节中介绍的内容大部分和<a href="http://www.csdn.net/article/2015-01-20/2823621-android-performance-patterns" target="_blank">Android性能优化典范</a>与<a href="http://www.csdn.net/article/2015-04-15/2824477-android-performance/3" target="_blank">Android性能优化之内存篇</a>重合，不展开了。</p><p><b>相关阅读：</b></p><p><b><a href="http://www.csdn.net/article/2015-01-20/2823621-android-performance-patterns" target="_blank">Android性能优化典范（一）</a><br/></b></p><p><a href="http://www.csdn.net/article/2015-04-15/2824477-android-performance" target="_blank"><b>Google《Android性能优化》学习笔记</b></a></p><hr/><p><img src="Android性能优化典范（二）-CSDN.NET_files/554076f5583cd.jpg" type="image/jpeg" data-filename="554076f5583cd.jpg" height="1020" width="1000"/><b>作者简介：</b></p><p><b>胡凯（<a href="http://weibo.com/kesenhoo" target="_blank">@胡凯me</a>），资深Android开发工程师，目前就职于腾讯公司，负责QQ空间水印相机、天天P图等Android应用的开发工作。个人博客：<a href="http://hukai.me/" target="_blank">http://hukai.me</a>，Github：<a href="https://github.com/kesenhoo" target="_blank">https://github.com/kesenhoo</a>。</b></p><hr/><p><b>CSDN移动将持续为您优选移动开发的精华内容，共同探讨移动开发的技术热点话题，涵盖移动应用、开发工具、移动游戏及引擎、智能硬件、物联网等方方面面，如果您有想分享的技术、观点，可通过电子邮件（tangxy#csdn.net，请把#改成@）投稿。</b></p><p><b>第一时间掌握最新移动开发相关信息和技术，请关注mobilehub公众微信号（ID: mobilehub)。</b></p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55306b78ab20e_middle.jpg" type="image/jpeg" data-filename="55306b78ab20e_middle.jpg" height="240" width="240"/></div><p></p><p><b>本文为CSDN原创文章，未经允许不得转载，如需转载请联系market#csdn.net(#换成@)</b></p>
				</div></div><div><div></div><div><em>第 2 页</em></div></div><div><div>
				<p><b>5) Object Pools</b></p><p>在程序里面经常会遇到的一个问题是短时间内创建大量的对象，导致内存紧张，从而触发GC导致性能问题。对于这个问题，我们可以使用对象池技术来解决它。通常对象池中的对象可能是bitmaps，views，paints等等。关于对象池的操作原理，不展开述说了，请看下面的图示：</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407aa6a44ad.jpg" type="image/jpeg" data-filename="55407aa6a44ad.jpg" height="316" width="491"/></div><p></p><p>使用对象池技术有很多好处，它可以避免内存抖动，提升性能，但是在使用的时候有一些内容是需要特别注意的。通常情况下，初始化的对象池里面都是空白的，当使用某个对象的时候先去对象池查询是否存在，如果不存在则创建这个对象然后加入对象池，但是我们也可以在程序刚启动的时候就事先为对象池填充一些即将要使用到的数据，这样可以在需要使用到这些对象的时候提供更快的首次加载速度，这种行为就叫做<b>预分配</b>。使用对象池也有不好的一面，程序员需要手动管理这些对象的分配与释放，所以我们需要慎重地使用这项技术，避免发生对象的内存泄漏。为了确保所有的对象能够正确被释放，我们需要保证加入对象池的对象和其他外部对象没有互相引用的关系。</p><p><b>6) To Index or Iterate?</b></p><p>遍历容器是编程里面一个经常遇到的场景。在Java语言中，使用Iterate是一个比较常见的方法。可是在Android开发团队中，大家却尽量避免使用Iterator来执行遍历操作。下面我们看下在Android上可能用到的三种不同的遍历方法：</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407ad579384.jpg" type="image/jpeg" data-filename="55407ad579384.jpg" height="170" width="472"/></div><p></p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407aed4c409.jpg" type="image/jpeg" data-filename="55407aed4c409.jpg" height="199" width="431"/></div><p></p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407b00a32f8.jpg" type="image/jpeg" data-filename="55407b00a32f8.jpg" height="161" width="355"/></div><p></p><p>使用上面三种方式在同一台手机上，使用相同的数据集做测试，他们的表现性能如下所示：</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407b1589dfd.jpg" type="image/jpeg" data-filename="55407b1589dfd.jpg" height="322" width="398"/></div><p></p><p>从上面可以看到for index的方式有更好的效率，但是因为不同平台编译器优化各有差异，我们最好还是针对实际的方法做一下简单的测量比较好，拿到数据之后，再选择效率最高的那个方式。</p><p><b>7) The Magic of LRU Cache</b></p><p>这小节我们要讨论的是缓存算法，在Android上面最常用的一个缓存算法是LRU(Least Recently Use)，关于LRU算法，不展开述说，用下面一张图演示下含义：</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407b32c6faf.jpg" type="image/jpeg" data-filename="55407b32c6faf.jpg" height="255" width="429"/></div><p></p><p>LRU Cache的基础构建用法如下：</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407b4bed244.jpg" type="image/jpeg" data-filename="55407b4bed244.jpg" height="111" width="436"/></div><p></p><p>为了给LRU Cache设置一个比较合理的缓存大小值，我们通常是用下面的方法来做界定的：</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407b65b4708.jpg" type="image/jpeg" data-filename="55407b65b4708.jpg" height="200" width="452"/></div><p></p><p>使用LRU Cache时为了能够让Cache知道每个加入的Item的具体大小，我们需要Override下面的方法：</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407b7e9510c_middle.jpg" type="image/jpeg" data-filename="55407b7e9510c_middle.jpg" height="233" width="550"/></div><p></p><p>使用LRU Cache能够显著提升应用的性能，可是也需要注意LRU Cache中被淘汰对象的回收，否者会引起严重的内存泄露。</p><p><b>8) Using LINT for Performance Tips</b></p><p>Lint是Android提供的一个静态扫描应用源码并找出其中的潜在问题的一个强大的工具。</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407b9b98690_middle.jpg" type="image/jpeg" data-filename="55407b9b98690_middle.jpg" height="341" width="550"/></div><p></p><p>例如，如果我们在onDraw方法里面执行了new对象的操作，Lint就会提示我们这里有性能问题，并提出对应的建议方案。Lint已经集成到Android Studio中了，我们可以手动去触发这个工具，点击工具栏的Analysis -&gt; Inspect Code，触发之后，Lint会开始工作，并把结果输出到底部的工具栏，我们可以逐个查看原因并根据指示做相应的优化修改。</p><p>Lint的功能非常强大，他能够扫描各种问题。当然我们可以通过Android Studio设置找到Lint，对Lint做一些定制化扫描的设置，可以选择忽略掉那些不想Lint去扫描的选项，我们还可以针对部分扫描内容修改它的提示优先级。</p><p>建议把与内存有关的选项中的严重程度标记为红色的Error，对于Layout的性能问题标记为黄色Warning。				
				</p>
				</div></div><div><div></div><div><em>第 3 页</em></div></div><div><div>
				<p><b>9) Hidden Cost of Transparency</b></p><p>这小节会介绍如何减少透明区域对性能的影响。通常来说，对于不透明的View，显示它只需要渲染一次即可，可是如果这个View设置了alpha值，会至少需要渲染两次。原因是包含alpha的view需要事先知道混合View的下一层元素是什么，然后再结合上层的View进行Blend混色处理。</p><p>在某些情况下，一个包含alpha的View有可能会触发改View在HierarchyView上的父View都被额外重绘一次。下面我们看一个例子，下图演示的ListView中的图片与二级标题都有设置透明度。</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407bd6c2b9a.jpg" type="image/jpeg" data-filename="55407bd6c2b9a.jpg" height="428" width="299"/></div><p></p><p>大多数情况下，屏幕上的元素都是由后向前进行渲染的。在上面的图示中，会先渲染背景图(蓝，绿，红)，然后渲染人物头像图。如果后渲染的元素有设置alpha值，那么这个元素就会和屏幕上已经渲染好的元素做blend处理。很多时候，我们会给整个View设置alpha的来达到fading的动画效果，如果我们图示中的ListView做alpha逐渐减小的处理，我们可以看到ListView上的TextView等等组件会逐渐融合到背景色上。但是在这个过程中，我们无法观察到它其实已经触发了额外的绘制任务，我们的目标是让整个View逐渐透明，可是期间ListView在不停的做Blending的操作，这样会导致不少性能问题。</p><p>如何渲染才能够得到我们想要的效果呢？我们可以先按照通常的方式把View上的元素按照从后到前的方式绘制出来，但是不直接显示到屏幕上，而是使用GPU预处理之后，再又GPU渲染到屏幕上，GPU可以对界面上的原始数据直接做旋转，设置透明度等等操作。使用GPU进行渲染，虽然第一次操作相比起直接绘制到屏幕上更加耗时，可是一旦原始纹理数据生成之后，接下去的操作就比较省时省力。</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407bf5347f8.jpg" type="image/jpeg" data-filename="55407bf5347f8.jpg" height="217" width="447"/></div><p></p><p>如何才能够让GPU来渲染某个View呢？我们可以通过setLayerType的方法来指定View应该如何进行渲染，从SDK 16开始，我们还可以使用ViewPropertyAnimator.alpha().withLayer()来指定。如下图所示：</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407c0ec30da.jpg" type="image/jpeg" data-filename="55407c0ec30da.jpg" height="186" width="419"/></div><p></p><p>另外一个例子是包含阴影区域的View，这种类型的View并不会出现我们前面提到的问题，因为他们并不存在层叠的关系。</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407c2bde99c.jpg" type="image/jpeg" data-filename="55407c2bde99c.jpg" height="257" width="490"/></div><p></p><p>为了能够让渲染器知道这种情况，避免为这种View占用额外的GPU内存空间，我们可以做下面的设置。</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407c4596a3d.jpg" type="image/jpeg" data-filename="55407c4596a3d.jpg" height="239" width="443"/></div><p></p><p>通过上面的设置以后，性能可以得到显著的提升，如下图所示：</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407c59c583f.jpg" type="image/jpeg" data-filename="55407c59c583f.jpg" height="277" width="511"/></div><p></p><p><b>10) Avoiding Allocations in onDraw()</b></p><p>我们都知道应该避免在onDraw()方法里面执行导致内存分配的操作，下面讲解下为何需要这样做。</p><p>首先onDraw()方法是执行在UI线程的，在UI线程尽量避免做任何可能影响到性能的操作。虽然分配内存的操作并不需要花费太多系统资源，但是这并不意味着是免费无代价的。设备有一定的刷新频率，导致View的onDraw方法会被频繁的调用，如果onDraw方法效率低下，在频繁刷新累积的效应下，效率低的问题会被扩大，然后会对性能有严重的影响。</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407c84e7351.jpg" type="image/jpeg" data-filename="55407c84e7351.jpg" height="136" width="502"/></div><p></p><p>如果在onDraw里面执行内存分配的操作，会容易导致内存抖动，GC频繁被触发，虽然GC后来被改进为执行在另外一个后台线程(GC操作在2.3以前是同步的，之后是并发)，可是频繁的GC的操作还是会影响到CPU，影响到电量的消耗。</p><p>那么简单解决频繁分配内存的方法就是把分配操作移动到onDraw()方法外面，通常情况下，我们会把onDraw()里面new Paint的操作移动到外面，如下面所示：</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407c9d35d69.jpg" type="image/jpeg" data-filename="55407c9d35d69.jpg" height="130" width="389"/></div><p></p><p><b>11) Tool: Strict Mode</b></p><p>UI线程被阻塞超过5秒，就会出现ANR，这太糟糕了。防止程序出现ANR是很重要的事情，那么如何找出程序里面潜在的坑，预防ANR呢？很多大部分情况下执行很快的方法，但是他们有可能存在巨大的隐患，这些隐患的爆发就很容易导致ANR。</p><p>Android提供了一个叫做Strict Mode的工具，我们可以通过手机设置里面的开发者选项，打开Strict Mode选项，如果程序存在潜在的隐患，屏幕就会闪现红色。我们也可以通过<a href="http://developer.android.com/reference/android/os/StrictMode.html" target="_blank">StrictMode</a> API在代码层面做细化的跟踪，可以设置StrictMode监听那些潜在问题，出现问题时如何提醒开发者，可以对屏幕闪红色，也可以输出错误日志。下面是官方的代码示例：</p><pre>public void onCreate() {
     if (DEVELOPER_MODE) {
         StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
                 .detectDiskReads()
                 .detectDiskWrites()
                 .detectNetwork()   // or .detectAll() for all detectable problems
                 .penaltyLog()
                 .build());
         StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()
                 .detectLeakedSqlLiteObjects()
                 .detectLeakedClosableObjects()
                 .penaltyLog()
                 .penaltyDeath()
                 .build());
     }
     super.onCreate();
}</pre><p><b>12) Custom Views and Performance</b></p><p>Android系统有提供超过70多种标准的View，例如TextView，ImageView，Button等等。在某些时候，这些标准的View无法满足我们的需要，那么就需要我们自己来实现一个View，这节会介绍如何优化自定义View的性能。</p><p>通常来说，针对自定义View，我们可能犯下面三个错误：</p><ul><li>Useless calls to onDraw()：我们知道调用View.invalidate()会触发View的重绘，有两个原则需要遵守，第1个是仅仅在View的内容发生改变的时候才去触发invalidate方法，第2个是尽量使用ClipRect等方法来提高绘制的性能。</li><li>Useless pixels：减少绘制时不必要的绘制元素，对于那些不可见的元素，我们需要尽量避免重绘。</li><li>Wasted CPU cycles：对于不在屏幕上的元素，可以使用Canvas.quickReject把他们给剔除，避免浪费CPU资源。另外尽量使用GPU来进行UI的渲染，这样能够极大的提高程序的整体表现性能。</li></ul><p>最后请时刻牢记，尽量提高View的绘制性能，这样才能保证界面的刷新帧率尽量的高。</p><p><b>13) Batching Background Work Until Later</b></p><p>优化性能时大多数时候讨论的都是如何减少不必要的操作，但是选择何时去执行某些操作同样也很重要。在<a href="http://www.csdn.net/article/2015-01-20/2823621-android-performance-patterns" target="_blank">第1季</a>以及上一期的<a href="http://www.csdn.net/article/2015-04-15/2824477-android-performance/4" target="_blank">性能优化之电量篇</a>里面，我们有提到过移动蜂窝模块的电量消耗模型。为了避免我们的应用程序过多的频繁消耗电量，我们需要学习如何把后台任务打包批量，并选择一个合适的时机进行触发执行。下图是每个应用程序各自执行后台任务导致的电量消耗示意图：</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407d34cb339.jpg" type="image/jpeg" data-filename="55407d34cb339.jpg" height="313" width="503"/></div><p></p><p>因为像上面那样做会导致浪费很多电量，我们需要做的是把部分应用的任务延迟处理，等到一定时机，这些任务一并进行处理。结果如下面的示意图：</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407d5c5ff00.jpg" type="image/jpeg" data-filename="55407d5c5ff00.jpg" height="346" width="487"/></div><p></p><p>执行延迟任务，通常有下面三种方式：</p><ul><li>AlarmManager：使用AlarmManager设置定时任务，可以选择精确的间隔时间，也可以选择非精确时间作为参数。除非程序有很强烈的需要使用精确的定时唤醒，否者一定要避免使用他，我们应该尽量使用非精确的方式。</li></ul><ul><li>SyncAdapter：我们可以使用SyncAdapter为应用添加设置账户，这样在手机设置的账户列表里面可以找到我们的应用。这种方式功能更多，但是实现起来比较复杂（<a href="http://developer.android.com/training/sync-adapters/index.html" target="_blank">Google官方培训课程</a>）</li></ul><ul><li>JobSchedulor：这是最简单高效的方法，我们可以设置任务延迟的间隔，执行条件，还可以增加重试机制。</li></ul><p><b>14) Smaller Pixel Formats</b></p><p>常见的png,jpeg,webp等格式的图片在设置到UI上之前需要经过解码的过程，而解压时可以选择不同的解码率，不同的解码率对内存的占用是有很大差别的。在不影响到画质的前提下尽量减少内存的占用，这能够显著提升应用程序的性能。</p><p>Android的Heap空间是不会自动做兼容压缩的，意思就是如果Heap空间中的图片被收回之后，这块区域并不会和其他已经回收过的区域做重新排序合并处理，那么当一个更大的图片需要放到heap之前，很可能找不到那么大的连续空闲区域，那么就会触发GC，使得heap腾出一块足以放下这张图片的空闲区域，如果无法腾出，就会发生OOM。如下图所示：</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407dd1c42e2.jpg" type="image/jpeg" data-filename="55407dd1c42e2.jpg" height="314" width="442"/></div><p></p><p>所以为了避免加载一张超大的图片，需要尽量减少这张图片所占用的内存大小，Android为图片提供了4种解码格式，他们分别占用的内存大小如下图所示：</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407dd1c42e2 [1].jpg" type="image/jpeg" data-filename="55407dd1c42e2.jpg" height="314" width="442"/></div><p></p><p>随着解码占用内存大小的降低，清晰度也会有损失。我们需要针对不同的应用场景做不同的处理，大图和小图可以采用不同的解码率。在Android里面可以通过下面的代码来设置解码率：</p><p></p><div><img src="Android性能优化典范（二）-CSDN.NET_files/55407de794232.jpg" type="image/jpeg" data-filename="55407de794232.jpg" height="184" width="451"/></div><p></p>
				</div></div></div><br/></div></span>
</div></body></html> 