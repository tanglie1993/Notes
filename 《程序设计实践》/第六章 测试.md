- 问题当然是发现得越早越好。如果你在写代码时就系统地考虑了应该写什么，那么也可以在程序构造过程中验证它的简单性质。

- 测试代码的边界情况。

- 防止问题发生的另一个方法，是验证在某段代码执行前所期望的或必须满足的性质 ( 前条件)、执行后的性质 ( 后条件) 是否成立。

- 断言机制对于检验界面性质特别有用，因为它可以使人注意到调用和被调用之间的不一致性，并可以进一步指出麻烦究竟是出在哪里。

- 有一种很有用的技术，那就是在程序里增加一些代码，专门处理所有“不可能”出现的情况，也就是处理那些从逻辑上讲不可能发生，但是或许 ( 由于其他地方的某些失误)可能出现的情况。

- 检查错误的返回值。一个常被忽略的防御措施是检查库函数或系统调用的返回值。

- 检查输出函数( 例如fprintf或fwrite)的返回值也可以发现一些错误，例如，要向一个文件写入，而磁盘上已经没有空间了。

<b>在编程的过程中测试，其花费是最小的，而回报却特别优厚。在写程序过程中考虑测试问题，得到的将是更好的代码，因为在这时你对代码应该做些什么了解得最清楚。如果不这样做，而是一直等到某种东西崩溃了，到那时你可能已经忘记了代码是怎样工作的。即使是在强大的工作压力下，你也还必须重新把它弄清楚，这又要花费许多时间。</b>

###系统化测试：

- 以递增方式做测试。测试应该与程序的构造同步进行。

- 测试应该首先集中在程序中最简单的最经常执行的部分，只有在这些部分能正确工作之后，才应该继续下去。这样，在每个步骤中你使更多的东西经过了测试，对程序基本机制能够正确工作也建立了信心。

- 如果一个程序有逆计算，那么就检查通过该逆计算能否重新得到输入。

- 检验应保持不变的特征。

- 对于那些应该保持不变的特征，实际上也可以在程序内部进行检查。

- 有时一个回答可以由两条完全不同的途径得到，或许你可以写出一个程序的某种简单版本，作为一个慢的但却又是独立的参照物。

- 度量测试的覆盖面（完全覆盖常常很难做到，即使是不考虑那些“不可能发生”的语句）。

###测试自动化：

- 自动化的最基本形式是回归测试，也就是说执行一系列测试，对某些东西的新版本与以前的版本做一个比较。在更正了一个错误之后，人们往往有一种自然的倾向，那就是只检查所做修改是否能行，但却经常忽略问题的另一面，所做的这个修改也可能破坏了其他东西。

- 回归测试实际上有一个隐含假定，假定程序以前的版本产生的输出是正确的。这个情况必须在开始时仔细进行审查，使这些不变性质能够一丝不苟地维持下去。

- 如果你发现了一个程序错误，那么又该怎么办？如果这个错误不是通过已有的测试发现的，那么你就应该建立一个能发现这个问题的新测试，并用那个崩溃的代码版本检验这个测试。

- 不要简单地把测试丢掉，因为它能够帮你确定一个错误报告是否正确，或是说明某些东西已经更正了。

- 要孤立地测试一个部件，通常必须构造出某种框架或者说是测试台，它应能提供足够的支持，并提供系统其他部分的一个界面，被测试部分将在该系统里运行。

###应力测试：

- 采用大量由机器生成的输入是另一种有效的测试技术。机器生成的输入对程序的压力与人写的输入有所不同。量大本身也能够破坏某些东西，因为大量的输入可能导致输入缓冲区、数组或者计数器的溢出。

- 通过随机输入测试，考查的主要是程序的内部检查和防御机制，因为在这种情况下一般无法验证程序产生的输出是否正确。这种测试的目标主要是设法引起程序垮台，或者让它出现“不可能发生的情况” ，而不是想发现直接的错误。

- 有些测试是针对明显的恶意输入进行的。安全性攻击经常使用极大的或者不合法的输入，设法引起对已有数据的覆盖。

###测试秘诀：

- 让散列函数返回某个常数值，使所有元素都跑到同一个散列桶里。

- 写一个你自己的存储分配函数，有意让它早早地就失败，利用它测试在出现存储器耗尽错误时设法恢复系统的那些代码。

- 把数组和变量初始化为某个可辨认的值，而不是总用默认的 0。这样，如果出现越界访问，或者取到了一个未初始化的变量值，你将更容易注意到它。

- 变动你的测试实例，特别是在用手工做小测试时。总使用同样东西很容易使人陷入某种常规，很可能忽略了其他的崩溃情况。

- 如果已经发现有错误存在，那么就不要继续设法去实现新特征或者再去测试已有的东西，因为那些错误有可能影响测试的结果。

- 测试输出中应该包括所有的参数设置，这可以使人容易准确地重做同样的测试。

- 在不同的机器、编译系统和操作系统上做测试。

- 你应该试着不考虑代码本身，仔细考虑最困难的测试实例，而不是那些容易的。

- 交互式程序应该能够通过脚本控制，这样我们就可以用脚本模拟用户的行为，使测试可以通过程序完成。这方面的一种技术是捕捉真实用户的动作，并重新播放它；另一种技术是建立一个能表述事件序列和时间的脚本语言。

- 最后，还应该想一想如何测试所用的测试代码本身。